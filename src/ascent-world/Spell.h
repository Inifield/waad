/*
 * Ascent MMORPG Server
 * Copyright (C) 2005-2008 Ascent Team <http://www.ascentcommunity.com/>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef __SPELL_H
#define __SPELL_H

#include "SpellFailure.h"
#include "StdAfx.h"

class WorldSession;
class Unit;
class DynamicObj;
class Player;
class Item;
class Group;
class Aura;
/* Spell Ranges:(for 1.10.2)
Note anything 50000 yards or longer ignores line of sight
Range ID|Range|Description
1       0-0     Self Only
2       0-5     Combat Range
3       0-20    Short Range
4       0-30    Medium Range
5       0-40    Long Range
6       0-100   Vision Range
7       0-10    Very Short Range
8       10-20   Short Range
9       10-30   Medium Range
10      10-40   Long Range
11      0-15    Shorter Range
12      0-5     Interact Range
13      0-50000 Anywhere
14      0-60    Extra Long Range
34      0-25    Medium-Short Range
35      0-35    Medium-Long Range
36      0-45    Longer Range
37      0-50    Extended Range
38      10-25   Extra Medium Range
54      5-30    Geoff Monster Shoot
74      8-30    Ranged Weapon
94      8-40    Sting
95      8-25    Charge
96      0-2     Trap
114     8-35    Hunter Range Hunter
134     0-80    Tower 80 Tower
135     0-100   Tower 100 Tower
*/

/*FLAT PCT
0    x    x
1    x    x
2    x    x
3         x
4    x
5    x    x
6    x    x
7    x =  x//both add % to crit
8    x    x
9         x
10   x    x
11   x    x
12   x
13    
14   x    x
15        x
16   x    
17   x
18   x    x
19   x
20        x
21    
22   x    x
23   x(enslave dem)
24    
25
26   x(obsolete)
27        x
*/
#define _SPELL_DURATION_INDEX_MAX		600 // 332.11403

//wooohooo, there are 19 spells that actually require to add a proccounter for these 
//first spell catched is "presence of mind"
//an ugly solution would be to add a proc flag to remove aura on event it should expire (like attack or cast) but that is only if count=1
enum SPELL_MODIFIER_TYPE
{
	SMT_DAMAGE_DONE         =0,// increases the damage done by spell by x% dmg (flat as x dmg)
	SMT_DURATION            =1,// spell    duration increase // GOOD
	SMT_THREAT_REDUCED      =2,// reduces threat generated by this spell by x% // GOOD
	SMT_EFFECT_1            =3,// modifies the first effect of the spell
	SMT_CHARGES             =4,// additional charges // GOOD
	SMT_RANGE               =5,// spell range bonus // GOOD
	SMT_RADIUS              =6,// spell radius bonus // GOOD
	SMT_CRITICAL            =7,// critical chance bonus // GOOD
	SMT_SPELL_VALUE         =8,// dummy effect // needs work, seems to always be related to pets
	SMT_NONINTERRUPT        =9,// x% reduction to pushback
	SMT_CAST_TIME           =10,// cast time decrease // GOOD
	SMT_COOLDOWN_DECREASE   =11,// cooldown decrease <-probably fully handled by client // GOOD
	SMT_EFFECT_2            =12,// modifies the second effect of the spell
	// 13 dont exist spells with it
	SMT_COST                =14,// mana/energy/rage cost reduction // GOOD
	SMT_CRITICAL_DAMAGE     =15,// increases critical strike damage bonus (no flat)
	SMT_HITCHANCE           =16,// enemy resist chance decrease (flat as %) // GOOD need work
	SMT_ADDITIONAL_TARGET   =17,// Your Healing Wave will now jump to additional nearby targets. // GOOD
	SMT_TRIGGER             =18,// adds/increases chance to trigger some spell for example increase chance to apply poisons or entaglin // GOOD need work
	SMT_AMPTITUDE           =19,// modifies the amptitude in periodic triggers
	SMT_JUMP_REDUCE         =20,// Increases the amount healed by Chain Heal to targets beyond the first by x%. (no flat)
	SMT_GCD_REDUCE			=21,

	SMT_SPELL_VALUE_PCT		=22,// 
	SMT_EFFECT_3            =23,// modifies the third effect of the spell
	SMT_PENALTY             =24,// This is a modifer for the amount of +spell damage applied to the spell group from spell bonuses
	// 25 dont exist spells with it
	// 26 is obsolete stuff
	SMT_EFFECT_BONUS        =27,// mana lost cost per point of damage taken for mana shield,Health or Mana gained from Drain Life and Drain Mana increased by x%.
	SMT_RESIST_DISPEL       =28,// TODO NEEDS WORK :D
};

// Modif Andy,V5086 SpellRelationGroup est codé maintenant sur 3 uint16 
// Je conserve la surcharge des fonctions pour compatibilité (Branruz)
static bool HasGroupBit(uint8 index, SpellEntry* sp)
{
	if (sp == NULL) return false;

	if (index < 32)
	{
		if (((uint64) 1 << index) & sp->SpellGroupType[0])
			return true;
	}
	else if (index < 64)
	{
		if (((uint64)1 << (index - 32)) & sp->SpellGroupType[1])
			return true;
	}
	else if (index < 96)
	{
		if (((uint64) 1 << (index - 64)) & sp->SpellGroupType[2])
			return true;
	}
	
	return false;
}

static bool HasSpellMaskBit(uint8 index, uint8 i, SpellEntry* sp)
{
    if (sp == NULL) return false;

	if (index < 32)
	{
		switch (i)
		{
		case 0: if (((uint64) 1 << index) & sp->SpellEffectMaskA[0]) return true; break;
		case 1: if (((uint64) 1 << index) & sp->SpellEffectMaskB[0]) return true; break;
		case 2: if (((uint64) 1 << index) & sp->SpellEffectMaskC[0]) return true; break;
		}
	}
	else if (index < 64)
	{
		switch (i)
		{
		case 0: if (((uint64) 1 << (index - 32)) & sp->SpellEffectMaskA[1]) return true; break;
		case 1: if (((uint64) 1 << (index - 32)) & sp->SpellEffectMaskB[1]) return true; break;
		case 2: if (((uint64) 1 << (index - 32)) & sp->SpellEffectMaskC[1]) return true; break;
		}
	}
	else if (index < 96)
	{
		switch (i)
		{
		case 0: if (((uint64) 1 << (index - 64)) & sp->SpellEffectMaskA[2]) return true; break;
		case 1: if (((uint64) 1 << (index - 64)) & sp->SpellEffectMaskB[2]) return true; break;
		case 2: if (((uint64) 1 << (index - 64)) & sp->SpellEffectMaskC[2]) return true; break;
		}
	}
	
	return false;
}


static void SM_FFValue(int32* m, float* v, SpellEntry* sp)
{
    if( m == 0 )
		return;

    for( uint32 x = 0; x < SPELL_GROUPS; x++ )
        if(HasGroupBit(x, sp))
            (*v) += m[x];
}

static void SM_FIValue(int32* m, int32* v, SpellEntry* sp)
{
    if( m == 0 )
		return;

    for( uint32 x = 0; x < SPELL_GROUPS; x++ )
        if(HasGroupBit(x, sp))
		{
            (*v) += m[x];
		}
}

static void SM_PIValue(int32* m, int32* v, SpellEntry* sp)
{
    if( m == 0 )
		return;

    for( uint32 x = 0; x < SPELL_GROUPS; x++ )
        if(HasGroupBit(x, sp))
            (*v) += (int32)(( (*v) * m[x] ) / 100.0f);
}

static void SM_PFValue(int32* m, float* v, SpellEntry* sp)
{
    if( m == 0 )
		return;
    
    for( uint32 x = 0; x < SPELL_GROUPS; x++ )
        if(HasGroupBit(x, sp))
            (*v) += ( (*v) * m[x] ) / 100.0f;
}

//bool IsBeneficSpell(SpellEntry *sp);
//AI_SpellTargetType RecommandAISpellTargetType(SpellEntry *sp);

enum DEFENSETYPE // 
{
	DEFENSE_TYPE_NONE   = 0,
	DEFENSE_TYPE_MAGIC  = 1,
	DEFENSE_TYPE_MELEE  = 2,
	DEFENSE_TYPE_RANGED = 3
};

// value's for SendSpellLog
enum SPELL_LOG
{
    SPELL_LOG_NONE,
    SPELL_LOG_MISS,
    SPELL_LOG_RESIST,
    SPELL_LOG_DODGE,
    SPELL_LOG_PARRY,
    SPELL_LOG_BLOCK,
    SPELL_LOG_EVADE,
    SPELL_LOG_IMMUNE,
    SPELL_LOG_IMMUNE2,
    SPELL_LOG_DEFLECT,
    SPELL_LOG_ABSORB,
    SPELL_LOG_REFLECT
};

enum SpellCastTargetFlags
{
    TARGET_FLAG_SELF                = 0x00000, // they are checked in following order
    TARGET_FLAG_UNK1                = 0x00001,
    TARGET_FLAG_UNIT                = 0x00002,
    TARGET_FLAG_UNK2                = 0x00004,
    TARGET_FLAG_UNK3                = 0x00008,
    TARGET_FLAG_ITEM                = 0x00010,
    TARGET_FLAG_SOURCE_LOCATION     = 0x00020,
    TARGET_FLAG_DEST_LOCATION       = 0x00040,
    TARGET_FLAG_OBJECT_CASTER       = 0x00080,
    TARGET_FLAG_CASTER              = 0x00100,
    TARGET_FLAG_CORPSE              = 0x00200,
    TARGET_FLAG_INERTE              = 0x00400,
    TARGET_FLAG_OBJECT              = 0x00800,
    TARGET_FLAG_TRADE_ITEM          = 0x01000,
    TARGET_FLAG_STRING              = 0x02000,
    TARGET_FLAG_ITEM2               = 0x04000,
    TARGET_FLAG_CORPSE2             = 0x08000,
	TARGET_FLAG_UNK5				= 0x10000,
	TARGET_FLAG_GLYPH				= 0x20000,
};

enum procFlags
{                                      // 0x000A22A8 
	PROC_NULL						   = 0x00000000,
	PROC_ON_ANY_HOSTILE_ACTION		   = 0x00000001,
	PROC_ON_XP_OR_HONOR_KILL		   = 0x00000002,
	PROC_ON_MELEE_HIT                  = 0x00000004, //on successful white melee attack
	PROC_ON_MELEE_HIT_VICTIM           = 0x00000008, //on successful white melee attack victim
	PROC_ON_MELEE_ABILITY_LAND         = 0x00000010, //on successful melee ability attack. Abilities that was resisted/dodged etc doesn't proc with this flag
	PROC_ON_MELEE_ABILITY_LAND_VICTIM  = 0x00000020, //on successful melee ability victim but not white damage. Abilities that was resisted/dodged etc doesn't proc with this flag
	PROC_ON_RANGED_HIT                 = 0x00000040,  //on successful ranged white attack
	PROC_ON_RANGED_HIT_VICTIM          = 0x00000080,  //on successful ranged white attack victim
	PROC_ON_RANGED_ABILITY_LAND        = 0x00000100, //on successful ranged ability attack. Abilities that was resisted/dodged etc doesn't proc with this flag
	PROC_ON_RANGED_ABILITY_LAND_VICTIM = 0x00000200,  //on successful ranged ability victim but not white damage. Abilities that was resisted/dodged etc doesn't proc with this flag
	PROC_ON_CAST_SPELL                 = 0x00000400, //on nonability (spell) cast. Spells that was resisted don't proc with this flag
	PROC_ON_CAST_SPELL_VICTIM          = 0x00000800,  //on nonability (spell) cast victim. Spells that was resisted don't proc with this flag.
	PROC_ON_CRIT_ATTACK                = 0x00001000, // mb wrong
	PROC_ON_CRIT_ATTACK_VICTIM         = 0x00002000, // mb wrong
	PROC_ON_HEALSPELL_LAND             = 0x00004000, //on heal (direct or HoT) spell land.
	PROC_ON_HEALSPELL_LAND_VICTIM      = 0x00008000,  //on heal (direct or HoT) spell land victim.
	PROC_ON_HARMFULSPELL_LAND          = 0x00010000, //on harmfull spell land (DoT damage not included in this flag!)
	PROC_ON_HARMFULSPELL_LAND_VICTIM   = 0x00020000, //on harmfull spell land victim (DoT damage not included in this flag!)
	PROC_ON_DOT_DAMAGE                 = 0x00040000, //on harmfull non direct damage (DoTs)
	PROC_ON_DOT_DAMAGE_VICTIM          = 0x00080000,  //on harmfull non direct damage (DoTs) victim
	PROC_ON_ANY_DAMAGE_VICTIM          = 0x00100000, //something supercustom. 99% wrong :P used by bombs and grenades in general.
	PROC_ON_TRAP_TRIGGER               = 0x00200000,
	PROC_ON_AUTO_SHOT_HIT              = 0x00400000,
	PROC_ON_OFFHAND_HIT                = 0x00800000, //only 1 spellname "Combat Potency"
	PROC_ON_DIE						   = 0x01000000,
	PROC_ON_DODGE_VICTIM			   = 0x02000000, //this isn't used
	PROC_ON_RESIST_VICTIM			   = 0x04000000, //this isn't used
    PROC_REMOVEONUSE                   = 0x08000000,//remove prochcharge only when it is used	
	PROC_MISC						   = 0x10000000,//our custom flag to decide if proc dmg or shield
	PROC_ON_BLOCK_VICTIM			   = 0x20000000, //this isn't used
	PROC_ON_SPELL_CRIT_HIT			   = 0x40000000, //this isn't used
	PROC_TARGET_SELF				   = 0x80000000,//our custom flag to decide if proc target is self or victim
};

enum CastinterruptFlags
{
    CAST_INTERRUPT_NULL            = 0x0,
    CAST_INTERRUPT_ON_SILENCE      = 0x1,
    CAST_INTERRUPT_ON_SLEEP        = 0x2, // could be wrong
    CAST_INTERRUPT_ON_STUNNED      = 0x4, // could be wrong
    CAST_INTERRUPT_ON_MOVEMENT     = 0x8,
    CAST_INTERRUPT_ON_DAMAGE_TAKEN = 0x10
};

enum auraInterruptFlags
{
    AURA_INTERRUPT_NULL                       = 0x000000,
    AURA_INTERRUPT_ON_HOSTILE_SPELL_INFLICTED = 0x000001,
    AURA_INTERRUPT_ON_ANY_DAMAGE_TAKEN        = 0x000002,
    AURA_INTERRUPT_ON_UNK1                    = 0x000004,
    AURA_INTERRUPT_ON_MOVEMENT                = 0x000008, // could be AURA_INTERRUPT_ON_MOVEMENT
    AURA_INTERRUPT_ON_UNK2                    = 0x000010,
    AURA_INTERRUPT_ON_UNK3                    = 0x000020,
    AURA_INTERRUPT_ON_UNUSED1                 = 0x000040,
    AURA_INTERRUPT_ON_SLOWED                  = 0x000080,
    AURA_INTERRUPT_ON_LEAVE_WATER             = 0x000100, // could be AURA_INTERRUPT_ON_LEAVE_CURRENT_SURFACE
    AURA_INTERRUPT_ON_UNUSED2                 = 0x000200,
    AURA_INTERRUPT_ON_UNK4                    = 0x000400,
    AURA_INTERRUPT_ON_UNK5                    = 0x000800,
    AURA_INTERRUPT_ON_START_ATTACK            = 0x001000,
    AURA_INTERRUPT_ON_UNK6                    = 0x002000,
    AURA_INTERRUPT_ON_UNUSED3                 = 0x004000,
    AURA_INTERRUPT_ON_CAST_SPELL              = 0x008000,
    AURA_INTERRUPT_ON_UNK7                    = 0x010000,
    AURA_INTERRUPT_ON_MOUNT                   = 0x020000,
    AURA_INTERRUPT_ON_STAND_UP                = 0x040000,
    AURA_INTERRUPT_ON_LEAVE_AREA              = 0x080000,
    AURA_INTERRUPT_ON_INVINCIBLE              = 0x100000,
    AURA_INTERRUPT_ON_STEALTH                 = 0x200000,
    AURA_INTERRUPT_ON_UNK8                    = 0x400000,
};

enum channelInterruptFlags
{
    CHANNEL_INTERRUPT_NULL  = 0x000000,
    CHANNEL_INTERRUPT_ON_1  = 0x000001,
    CHANNEL_INTERRUPT_ON_2  = 0x000002,
    CHANNEL_INTERRUPT_ON_3  = 0x000004,
    CHANNEL_INTERRUPT_ON_4  = 0x000008,
    CHANNEL_INTERRUPT_ON_5  = 0x000010,
    CHANNEL_INTERRUPT_ON_6  = 0x000020,
    CHANNEL_INTERRUPT_ON_7  = 0x000040,
    CHANNEL_INTERRUPT_ON_8  = 0x000080,
    CHANNEL_INTERRUPT_ON_9  = 0x000100,
    CHANNEL_INTERRUPT_ON_10 = 0x000200,
    CHANNEL_INTERRUPT_ON_11 = 0x000400,
    CHANNEL_INTERRUPT_ON_12 = 0x000800,
    CHANNEL_INTERRUPT_ON_13 = 0x001000,
    CHANNEL_INTERRUPT_ON_14 = 0x002000,
    CHANNEL_INTERRUPT_ON_15 = 0x004000,
    CHANNEL_INTERRUPT_ON_16 = 0x008000,
    CHANNEL_INTERRUPT_ON_17 = 0x010000,
    CHANNEL_INTERRUPT_ON_18 = 0x020000
};

enum attributes
{                                                // 18010010
	ATTRIBUTES_NULL								= 0x00000000,
	ATTRIBUTES_UNK2								= 0x00000001,
	ATTRIBUTES_UNK3								= 0x00000002, // related to ranged??
	ATTRIBUTE_ON_NEXT_ATTACK					= 0x00000004,
	ATTRIBUTES_UNUSED0							= 0x00000008,
	ATTRIBUTES_UNK6								= 0x00000010, // Nourrir le Familier (6991)
	ATTRIBUTES_UNK7								= 0x00000020, // Tradeskill recipies
	ATTRIBUTES_PASSIVE							= 0x00000040,
	ATTRIBUTES_NO_VISUAL_AURA					= 0x00000080,
	ATTRIBUTES_UNK10							= 0x00000100, // Batonnet de Dantheol 22473 spell 27907
	ATTRIBUTES_UNK11							= 0x00000200, // looks like temp enchants.
	ATTRIBUTES_UNK12							= 0x00000400, //completely the same as ATTRIBUTE_ON_NEXT_ATTACK for class spells. So difference somewhere in mob abilities.
	ATTRIBUTES_UNK13							= 0x00000800,
	ATTRIBUTES_UNUSED1							= 0x00001000,
	ATTRIBUTES_UNUSED2							= 0x00002000,
	ATTRIBUTES_UNUSED3							= 0x00004000,
	ATTRIBUTES_ONLY_OUTDOORS					= 0x00008000,
	ATTRIBUTES_UNK								= 0x00010000, // Spell 1515, Apprivoise un familier + Nourrir le Familier (6991)
	ATTRIBUTES_REQ_STEALTH						= 0x00020000,
	ATTRIBUTES_UNK20							= 0x00040000,//it's not : must be behind
	ATTRIBUTES_UNK21							= 0x00080000,
	ATTRIBUTES_STOP_ATTACK						= 0x00100000,//switch off auto attack on use. Maim,Gouge,Disengage,Polymorph etc
	ATTRIBUTES_CANT_BE_DPB				    	= 0x00200000,//can't be dodged, blocked, parried
	ATTRIBUTES_UNK24							= 0x00400000, // related to ranged
	ATTRIBUTES_UNK25							= 0x00800000,
	ATTRIBUTES_MOUNT_CASTABLE					= 0x01000000, //castable on mounts
	ATTRIBUTES_TRIGGER_COOLDOWN			        = 0x02000000, //also requires atributes ex = 32 ?
	ATTRIBUTES_UNK28							= 0x04000000,
	ATTRIBUTES_UNK29							= 0x08000000, // Nourrir le Familier (6991)
	ATTRIBUTES_REQ_OOC							= 0x10000000, // ATTRIBUTES_REQ_OUT_OF_COMBAT
    ATTRIBUTES_IGNORE_INVULNERABILITY           = 0x20000000, //debuffs that can't be removed by any spell and spells that can't be resisted in any case
	ATTRIBUTES_UNK32							= 0x40000000, // seems like IS_DIMINISHING but some spells not there (f.e. Gouge)
};

enum attributesEx
{
	ATTRIBUTESEX_NULL                         = 0x00000000, // 0
	ATTRIBUTESEX_UNK2                         = 0x00000001, // 1, pet summonings
	ATTRIBUTESEX_DRAIN_WHOLE_MANA             = 0x00000002, // 2
	ATTRIBUTESEX_UNK4                         = 0x00000004, // 3 // Spell 1515, apprivoise un familier
	ATTRIBUTESEX_AREA_OF_EFFECT               = 0x00000008, // 4
	ATTRIBUTESEX_UNK6                         = 0x00000010, // 5, stealth effects but Rockbiter wtf 0_0
	ATTRIBUTESEX_NOT_BREAK_STEALTH            = 0x00000020, // 6
	ATTRIBUTESEX_UNK8						  = 0x00000040, // 7 [POSSIBLY: dynamite, grenades from engineering etc..]
	ATTRIBUTESEX_UNK9                         = 0x00000080,
	ATTRIBUTESEX_UNK10                        = 0x00000100,
	ATTRIBUTESEX_UNK11                        = 0x00000200,
	ATTRIBUTESEX_VISUAL_AURA                  = 0x00000400,
	ATTRIBUTESEX_UNK13                        = 0x00000800,
	ATTRIBUTESEX_UNK14                        = 0x00001000, // related to pickpocket
	ATTRIBUTESEX_UNK15                        = 0x00002000, // related to remote control
	ATTRIBUTESEX_UNK16                        = 0x00004000, // Spell 1515, apprivoise un familier
	ATTRIBUTESEX_UNK17                        = 0x00008000, // something like "grant immunity"
	ATTRIBUTESEX_UNK18                        = 0x00010000, // something like "grant immunity" too
	ATTRIBUTESEX_REMAIN_OOC                   = 0x00020000, // Spell 1515, apprivoise un familier
	ATTRIBUTESEX_UNK20                        = 0x00040000,
	ATTRIBUTESEX_UNK21                        = 0x00080000,
	ATTRIBUTESEX_UNK22                        = 0x00100000, // related to "Finishing move" and "Instantly overpowers"
	ATTRIBUTESEX_UNK23                        = 0x00200000,
	ATTRIBUTESEX_UNK24                        = 0x00400000, // only related to "Finishing move"
	ATTRIBUTESEX_UNK25                        = 0x00800000, // related to spells like "ClearAllBuffs"
	ATTRIBUTESEX_UNK26                        = 0x01000000, // FISHING SPELLS
	ATTRIBUTESEX_UNK27                        = 0x02000000, // related to "Detect" spell
	ATTRIBUTESEX_UNK28                        = 0x04000000,
	ATTRIBUTESEX_UNK29                        = 0x08000000,
	ATTRIBUTESEX_UNK30                        = 0x10000000,
	ATTRIBUTESEX_UNK31                        = 0x20000000,
	ATTRIBUTESEX_UNK32                        = 0x40000000, // Overpower
};

enum attributesExB
{
	ATTRIBUTESEXB_NULL               = 0x00000000,
	ATTRIBUTESEXB_UNK2               = 0x00000001,
	ATTRIBUTESEXB_UNK3               = 0x00000002, // Can be used while stealthed
	ATTRIBUTESEXB_UNK4               = 0x00000004, // request pet maybe
	ATTRIBUTESEXB_UNK5               = 0x00000008, // something todo with temp enchanted items
	ATTRIBUTESEXB_PARTY_EFFECTING_AURA = 0x00000010, // Party affecting aura's
	ATTRIBUTESEXB_ACTIVATE_AUTO_SHOT = 0x00000020, // spell that enable's auto shoot
	ATTRIBUTESEXB_UNK8               = 0x00000040, //Polymorph spells
	ATTRIBUTESEXB_UNK9               = 0x00000080,
	ATTRIBUTESEXB_UNUSED1            = 0x00000100,
	ATTRIBUTESEXB_UNK11              = 0x00000200, // used by 2 spells, 30421 | Nether Portal - Perseverence and  30466 | Nether Portal - Perseverence
	ATTRIBUTESEXB_TAME_X             = 0x00000400, // tame [creature] [Familier]
	ATTRIBUTESEXB_FUNNEL             = 0x00000800, // only funnel spells
	ATTRIBUTESEXB_UNK14              = 0x00001000, // swipe / Cleave spells
	ATTRIBUTESEXB_ENCHANT_OWN_ONLY   = 0x00002000, // no trade window targets, BoE items get soulbound to you
	ATTRIBUTESEXB_SPELL_PLAYER_EVENT = 0x00004000, // Player event's like logging in, finishing quests, triggering cinematic, being adored, Heartbroken etc
	ATTRIBUTESEXB_UNUSED3            = 0x00008000,
	ATTRIBUTESEXB_CONTROL_UNIT       = 0x00010000, // PvP Controller, RC, Creature taming, Taming Lesson, Familier
	ATTRIBUTESEXB_REQ_RANGED_WEAPON  = 0x00020000, // this is shit and has nothing to do with auto shot
	ATTRIBUTESEXB_REVIVE_PET         = 0x00040000, // actually 1 spell, revive pet
	ATTRIBUTESEXB_UNK21              = 0x00080000, // this is a group of spells that are triggered by something. (I have no clue on how to name this one)
	ATTRIBUTESEXB_REQ_BEHIND_TARGET  = 0x00100000, //wrong
	ATTRIBUTESEXB_UNK23              = 0x00200000,
	ATTRIBUTESEXB_UNK24              = 0x00400000,
	ATTRIBUTESEXB_UNK25              = 0x00800000,
	ATTRIBUTESEXB_UNK26              = 0x01000000,
	ATTRIBUTESEXB_UNK27              = 0x02000000,
	ATTRIBUTESEXB_UNK28              = 0x04000000, // Spell 1515, apprivoise un familier
	ATTRIBUTESEXB_UNK29              = 0x08000000, // fishing spells and enchanting weapons
	ATTRIBUTESEXB_UNK30              = 0x10000000, // some secondairy spell triggers, especialy for lightning shield alike spells
	ATTRIBUTESEXB_UNK31              = 0x20000000,
	ATTRIBUTESEXB_UNK32              = 0x40000000,
};

enum attributesExC
{
	ATTRIBUTESEXC_SHIELD                            = 0x00000080, // Bouclier
	ATTRIBUTESEXC_BG_ONLY							= 0x00000800,
	ATTRIBUTESEXC_PLAYER_RANGED_SPELLS				= 0x00008000,
	ATTRIBUTESEXC_CAN_PERSIST_AND_CASTED_WHILE_DEAD	= 0x00100000,
	ATTRIBUTESEXC_PLAYER_RANGED_WAND				= 0x00400000,
	ATTRIBUTESEXC_OFFHAND                           = 0x01000000,
	ATTRIBUTESEXC_NO_HEALING_BONUS					= 0x02000000,
	ATTRIBUTESEXC_UNK1                              = 0x40000000,
};

enum attributesExD
{
	ATTRIBUTESEXD_PROCCHANCE_COMBOBASED        = 0x00000002,
	ATTRIBUTESEXD_ONLY_IN_OUTLANDS             = 0x04000000,
};

enum SpellCastFlags
{
    CAST_FLAG_UNKNOWN1           = 0x2,
    CAST_FLAG_UNKNOWN2           = 0x10, // no idea yet, i saw it in blizzard spell
    CAST_FLAG_AMMO               = 0x20 // load ammo display id (uint32) and ammo inventory type (uint32)
};

enum School
{
    SCHOOL_NORMAL = 0,
    SCHOOL_HOLY   = 1,
    SCHOOL_FIRE   = 2,
    SCHOOL_NATURE = 3,
    SCHOOL_FROST  = 4,
    SCHOOL_SHADOW = 5,
    SCHOOL_ARCANE = 6,
	SCHOOL_NOFIRE = 7,
	SCHOOL_MAGIC  = 8,
	SCHOOL_ALL	  = 9
};

enum SchoolMask
{
    SCHOOL_MASK_NORMAL 		= 0x01, // Physical
    SCHOOL_MASK_HOLY   		= 0x02, // Holy
    SCHOOL_MASK_FIRE   		= 0x04, // Fire
    SCHOOL_MASK_NATURE 		= 0x08, // Nature
	SCHOOL_MASK_FIRESTORM 	= 0x0C, // Nature + fire - Par randdrick - Source WoWWiki
    SCHOOL_MASK_FROST  		= 0x10, // Frost
	SCHOOL_MASK_FROSTFIRE  	= 0x14, // Frost + fire - Par randdrick - Source WoWWiki
	SCHOOL_MASK_FROSTORM  	= 0x18, // Frost + nature - Par randdrick - Source WoWWiki
    SCHOOL_MASK_SHADOW 		= 0x20, // Shadow
	SCHOOL_MASK_SHADOWSTROM = 0x28, // Shadow + Storm - Par randdrick - Source WoWWiki
	SCHOOL_MASK_SHADOWFROST = 0x30,	// Shadow + Frost - Par randdrick - Source WoWWiki
    SCHOOL_MASK_ARCANE 		= 0x40, // Arcane
	SCHOOL_MASK_SPELLFIRE 	= 0x44, // Arcane + fire - Par randdrick - Source WoWWiki
	//---- Test  (Branruz)
	SCHOOL_MASK_ARCANE_FROST = SCHOOL_MASK_ARCANE | SCHOOL_MASK_FROST, // __Arcane_Breath___0 56272
                                                                       // __Arcane_Breath___1 56279
																	   // __Arcane_Breath___2 60072
																	   // __Arcane_Breath___4 61079
	SCHOOL_MASK_ARCSHAD      = SCHOOL_MASK_ARCANE | SCHOOL_MASK_SHADOW, // __Psychic_Scream___4 43432
	SCHOOL_MASK_NOFIRE       = 0x7B, // __PvP_Vehicle_Health_Regen_Suppression 52455
	SCHOOL_MASK_MAGIC		 = 0x7E, // Magic 
	SCHOLL_MASK_ALL          = 0x7F, // __Physical_Debuffs_2   31966
	                                 // __Flames_of_Chaos___1  39055             
	                                 // __Rain_of_Chaos___2    40948
							         // __Chaos_Strike___1     42133
							         // __You_re_a_Zombie_     43869
							         // __Zombie_Dies          61454 
    //-----------
};

// converting schools for 2.4.0 client
static const uint32 g_spellSchoolConversionTable[SCHOOL_ALL+7] = 
{
	1,				// SCHOOL_NORMAL
	2,				// SCHOOL_HOLY
	4,				// SCHOOL_FIRE
	8,				// SCHOOL_NATURE
	12,				// SCHOOL_NATURE +  SCHOOL_FIRE - Par randdrick - Source WoWWiki
	16,				// SCHOOL_FROST
	20,				// SCHOOL_FROST +  SCHOOL_FIRE - Par randdrick - Source WoWWiki
	24, 			// SCHOOL_FROST +  SCHOOL_NATURE - Par randdrick - Source WoWWiki
	32,				// SCHOOL_SHADOW 
	40,				// SCHOOL_SHADOW +  SCHOOL_NATURE - Par randdrick - Source WoWWiki
	48, 			// SCHOOL_SHADOW +  SCHOOL_FROST - Par randdrick - Source WoWWiki
	64,				// SCHOOL_ARCANE
	68,				// SCHOOL_ARCANE + SCHOOL_FIRE - Par randdrick - Source WoWWiki
	123,			// SCHOOL_NOFIRE
	126,			// SCHOOL_MAGIC
	127				// SCHOOL_ALL
};

enum ReplenishType
{
    REPLENISH_UNDEFINED = 0,
    REPLENISH_HEALTH    = 20,
    REPLENISH_MANA      = 21,
    REPLENISH_RAGE      = 22 //don't know if rage is 22 or what, but will do for now
};

enum SpellRaceTargetType
{
    TARGET_TYPE_NULL       = 0x0,
    TARGET_TYPE_BEAST      = 0x1,
    TARGET_TYPE_DRAGONKIN  = 0x2,
    TARGET_TYPE_DEMON      = 0x4,
    TARGET_TYPE_ELEMENTAL  = 0x8,
    TARGET_TYPE_GIANT      = 0x10,
    TARGET_TYPE_UNDEAD     = 0x20,
    TARGET_TYPE_HUMANOID   = 0x40,
    TARGET_TYPE_CRITTER    = 0x80,
    TARGET_TYPE_MECHANICAL = 0x100,
};

/****************SpellExtraFlags*****************/
/* SpellExtraFlags defines                      */
/*                                              */
/* Used for infront check and other checks      */
/* when they are not in spell.dbc               */
/*                                              */
/************************************************/
#define SPELL_EXTRA_INFRONT 1
#define SPELL_EXTRA_BEHIND  2
#define SPELL_EXTRA_UNDEF0  4 // not used yet
#define SPELL_EXTRA_UNDEF1  8 // not used yet


/***************Ranged spellid*******************/
/* Note: These spell id's are checked for 2.0.x */
/************************************************/
// Test pour 3.0.9 (Branruz)
// En fait ca concerne essentiellement les armes de jet
// General = Arc, Arbalete, fusils
// Throw   = Arme de jet (couteau/hache)
// Wand    = Baguette
#define SPELL_RANGED_GENERAL    3018    //__Generic = 2382 (3018 = __Shoot ??) serait-ce le spell Generic ?
#define SPELL_RANGED_THROW      __Throw // 2764 (Ok Arme de Jet)
#define SPELL_RANGED_WAND       5019    //__Wands // (5019 = __Shoot___0 ??) __Wands = 5009 => 3.0.9

#pragma pack(push,1)
struct TeleportCoords
{
    uint32 id;
    uint32 mapId;
    float x;
    float y;
    float z;
};
#pragma pack(pop)

struct TotemSpells
{
    uint32 spellId;
    uint32 spellToCast[3];
};

enum LOCKTYPES{
	LOCKTYPE_NONE                   =  0, // Pas de Lock Specifique
    LOCKTYPE_PICKLOCK               =  1, // Crochetage
    LOCKTYPE_HERBALISM              =  2, // Herboristerie
    LOCKTYPE_MINING                 =  3, // Minage
    LOCKTYPE_DISARM_TRAP            =  4, // Dé-armenent de piège
    LOCKTYPE_OPEN                   =  5, // Ouverture
    LOCKTYPE_TREASURE               =  6, // Trésoir - DND
    LOCKTYPE_CALCIFIED_ELVEN_GEMS   =  7, // Gemmes Elfiques calcifiées - DND
    LOCKTYPE_CLOSE                  =  8, // Fermeture
    LOCKTYPE_ARM_TRAP               =  9, // Pose de piège
    LOCKTYPE_QUICK_OPEN             = 10, // Ouverture Rapide
    LOCKTYPE_QUICK_CLOSE            = 11, // Fermeture Rapide
    LOCKTYPE_OPEN_TINKERING         = 12, // Ouverture ( Bricolage )
    LOCKTYPE_OPEN_KNEELING          = 13, // Ouverture ( à genoux )
    LOCKTYPE_OPEN_ATTACKING         = 14, // Ouverture ( en Attaquant )
    LOCKTYPE_GAHZRIDIAN             = 15, // DND
    LOCKTYPE_BLASTING               = 16, // Explosif
    LOCKTYPE_SLOW_OPEN              = 17, // Ouverture JcJ
    LOCKTYPE_SLOW_CLOSE             = 18, // Fermeture JcJ
	LOCKTYPE_FISHING                = 19, // Peche
	LOCKTYPE_CALLIGRAPHE            = 20, // Caligraphie
	LOCKTYPE_VEHICLE                = 21, // Ouverture à partir d'un véhicule 
	MAX_LOCKTYPE
};

enum SpellEffects
{
    SPELL_EFFECT_NULL = 0,
    SPELL_EFFECT_INSTANT_KILL,              //    1
    SPELL_EFFECT_SCHOOL_DAMAGE,             //    2    
    SPELL_EFFECT_DUMMY,                     //    3    
    SPELL_EFFECT_PORTAL_TELEPORT,           //    4    
    SPELL_EFFECT_TELEPORT_UNITS,            //    5    
    SPELL_EFFECT_APPLY_AURA,                //    6    
    SPELL_EFFECT_ENVIRONMENTAL_DAMAGE,      //    7    
    SPELL_EFFECT_POWER_DRAIN,               //    8    
    SPELL_EFFECT_HEALTH_LEECH,              //    9    
    SPELL_EFFECT_HEAL,                      //    10    
    SPELL_EFFECT_BIND,                      //    11    
    SPELL_EFFECT_PORTAL,                    //    12
    SPELL_EFFECT_RITUAL_BASE,               //    13
    SPELL_EFFECT_RITUAL_SPECIALIZE,         //    14
    SPELL_EFFECT_RITUAL_ACTIVATE_PORTAL,    //    15
    SPELL_EFFECT_QUEST_COMPLETE,            //    16    
    SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL,    //    17    
    SPELL_EFFECT_RESURRECT,                 //    18    
    SPELL_EFFECT_ADD_EXTRA_ATTACKS,         //    19    
    SPELL_EFFECT_DODGE,                     //    20    
    SPELL_EFFECT_EVADE,                     //    21    
    SPELL_EFFECT_PARRY,                     //    22    
    SPELL_EFFECT_BLOCK,                     //    23    
    SPELL_EFFECT_CREATE_ITEM,               //    24    
    SPELL_EFFECT_WEAPON,                    //    25
    SPELL_EFFECT_DEFENSE,                   //    26
    SPELL_EFFECT_PERSISTENT_AREA_AURA,      //    27    
    SPELL_EFFECT_SUMMON,                    //    28    
    SPELL_EFFECT_LEAP,                      //    29    
    SPELL_EFFECT_ENERGIZE,                  //    30    
    SPELL_EFFECT_WEAPON_PERCENT_DAMAGE,     //    31    
    SPELL_EFFECT_TRIGGER_MISSILE,           //    32    
    SPELL_EFFECT_OPEN_LOCK,                 //    33    
    SPELL_EFFECT_TRANSFORM_ITEM,            //    34    
    SPELL_EFFECT_APPLY_AREA_AURA,           //    35    
    SPELL_EFFECT_LEARN_SPELL,               //    36    
    SPELL_EFFECT_SPELL_DEFENSE,             //    37    
    SPELL_EFFECT_DISPEL,                    //    38    
    SPELL_EFFECT_LANGUAGE,                  //    39
    SPELL_EFFECT_DUAL_WIELD,                //    40    
    SPELL_EFFECT_SUMMON_WILD,               //    41    
    SPELL_EFFECT_JUMP_MOVE,				    //    42    ,           //    42    
    SPELL_EFFECT_TELEPORT_UNITS_FACE_CASTER,//    43
    SPELL_EFFECT_SKILL_STEP,                //    44    
    SPELL_EFFECT_UNDEFINED_45,              //    45    
    SPELL_EFFECT_SPAWN,                     //    46
    SPELL_EFFECT_TRADE_SKILL,               //    47
    SPELL_EFFECT_STEALTH,                   //    48
    SPELL_EFFECT_DETECT,                    //    49
    SPELL_EFFECT_SUMMON_OBJECT,             //    50    
    //SPELL_EFFECT_TRANS_DOOR,              //    50    
    SPELL_EFFECT_FORCE_CRITICAL_HIT,        //    51
    SPELL_EFFECT_GUARANTEE_HIT,             //    52
    SPELL_EFFECT_ENCHANT_ITEM,              //    53    
    SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY,    //    54    
    SPELL_EFFECT_TAMECREATURE,              //    55    
    SPELL_EFFECT_SUMMON_PET,                //    56    
    SPELL_EFFECT_LEARN_PET_SPELL,           //    57    
    SPELL_EFFECT_WEAPON_DAMAGE,             //    58    
    SPELL_EFFECT_OPEN_LOCK_ITEM,            //    59    
    SPELL_EFFECT_PROFICIENCY,               //    60
    SPELL_EFFECT_SEND_EVENT,                //    61    
    SPELL_EFFECT_POWER_BURN,                //    62
    SPELL_EFFECT_THREAT,                    //    63
    SPELL_EFFECT_TRIGGER_SPELL,             //    64    
    SPELL_EFFECT_RAID_AREA_AURA,             //    65
    SPELL_EFFECT_POWER_FUNNEL,              //    66
    SPELL_EFFECT_HEAL_MAX_HEALTH,           //    67    
    SPELL_EFFECT_INTERRUPT_CAST,            //    68
    SPELL_EFFECT_DISTRACT,                  //    69
    SPELL_EFFECT_PULL,                      //    70
    SPELL_EFFECT_PICKPOCKET,                //    71
    SPELL_EFFECT_ADD_FARSIGHT,              //    72
    SPELL_EFFECT_SUMMON_POSSESSED,          //    73    
    SPELL_EFFECT_APPLY_GLYPH,               //    74    
    SPELL_EFFECT_HEAL_MECHANICAL,           //    75
    SPELL_EFFECT_SUMMON_OBJECT_WILD,        //    76
    SPELL_EFFECT_SCRIPT_EFFECT,             //    77    
    SPELL_EFFECT_ATTACK,                    //    78
    SPELL_EFFECT_SANCTUARY,                 //    79
    SPELL_EFFECT_ADD_COMBO_POINTS,          //    80    
    SPELL_EFFECT_CREATE_HOUSE,              //    81
    SPELL_EFFECT_BIND_SIGHT,                //    82
    SPELL_EFFECT_DUEL,                      //    83
    SPELL_EFFECT_STUCK,                     //    84
    SPELL_EFFECT_SUMMON_PLAYER,             //    85
    SPELL_EFFECT_ACTIVATE_OBJECT,           //    86
    SPELL_EFFECT_SUMMON_TOTEM_SLOT1,        //    87    
    SPELL_EFFECT_SUMMON_TOTEM_SLOT2,        //    88    
    SPELL_EFFECT_SUMMON_TOTEM_SLOT3,        //    89    
    SPELL_EFFECT_SUMMON_TOTEM_SLOT4,        //    90    
    SPELL_EFFECT_THREAT_ALL,                //    91
    SPELL_EFFECT_ENCHANT_HELD_ITEM,         //    92
    SPELL_EFFECT_SUMMON_PHANTASM,           //    93
    SPELL_EFFECT_SELF_RESURRECT,            //    94    
    SPELL_EFFECT_SKINNING,                  //    95    
    SPELL_EFFECT_CHARGE,                    //    96    
    SPELL_EFFECT_SUMMON_CRITTER,            //    97    
    SPELL_EFFECT_KNOCK_BACK,                //    98    
    SPELL_EFFECT_DISENCHANT,                //    99    
    SPELL_EFFECT_INEBRIATE,                 //    100    
    SPELL_EFFECT_FEED_PET,                  //    101
    SPELL_EFFECT_DISMISS_PET,               //    102
    SPELL_EFFECT_REPUTATION,                //    103
    SPELL_EFFECT_SUMMON_OBJECT_SLOT1,       //    104
    SPELL_EFFECT_SUMMON_OBJECT_SLOT2,       //    105
    SPELL_EFFECT_SUMMON_OBJECT_SLOT3,       //    106
    SPELL_EFFECT_SUMMON_OBJECT_SLOT4,       //    107
    SPELL_EFFECT_DISPEL_MECHANIC,           //    108    
    SPELL_EFFECT_SUMMON_DEAD_PET,           //    109
    SPELL_EFFECT_DESTROY_ALL_TOTEMS,        //    110
    SPELL_EFFECT_DURABILITY_DAMAGE,         //    111
    SPELL_EFFECT_SUMMON_DEMON,              //    112    
    SPELL_EFFECT_RESURRECT_FLAT,            //    113    
    SPELL_EFFECT_ATTACK_ME,                 //    114
    SPELL_EFFECT_DURABILITY_DAMAGE_PCT,     //    115
    SPELL_EFFECT_SKIN_PLAYER_CORPSE,        //    116
    SPELL_EFFECT_SPIRIT_HEAL,               //    117
    SPELL_EFFECT_SKILL,                     //    118
    SPELL_EFFECT_APPLY_PET_AURA,            //    119    
    SPELL_EFFECT_TELEPORT_GRAVEYARD,        //    120
    SPELL_EFFECT_DUMMYMELEE,                //    121
    SPELL_EFFECT_UNKNOWN1,                  //    122
    SPELL_EFFECT_UNKNOWN2,                  //    123
    SPELL_EFFECT_PLAYER_PULL,               //    124
    SPELL_EFFECT_UNKNOWN4,                  //    125
    SPELL_EFFECT_UNKNOWN5,                  //    126
    SPELL_EFFECT_PROSPECTING,               //    127
    SPELL_EFFECT_UNKNOWN7,                  //    128
    SPELL_EFFECT_UNKNOWN8,                  //    129
    SPELL_EFFECT_UNKNOWN9,                  //    129
    SPELL_EFFECT_UNKNOWN10,                 //    130
    SPELL_EFFECT_UNKNOWN11,                 //    131
    SPELL_EFFECT_UNKNOWN12,                 //    132
    SPELL_EFFECT_FORGET_SPECIALIZATION,     //    133
    SPELL_EFFECT_UNKNOWN14,                 //    134
    SPELL_EFFECT_UNKNOWN15,                 //    135
    SPELL_EFFECT_UNKNOWN16,                 //    136
    SPELL_EFFECT_UNKNOWN17,                 //    137
    SPELL_EFFECT_UNKNOWN18,                 //    138
    SPELL_EFFECT_UNKNOWN19,                 //    139
    SPELL_EFFECT_UNKNOWN20,                 //    140
    SPELL_EFFECT_UNKNOWN21,                 //    141
    SPELL_EFFECT_TRIGGER_SPELL_WITH_VALUE,	//    142
    SPELL_EFFECT_UNKNOWN23,                 //    143
	SPELL_EFFECT_MODIFY_GRAVITY,            //    144
	SPELL_EFFECT_REFRESH_RUNE,              //    145
	SPELL_EFFECT_FAIL_QUEST,	            //    146
    
	SPELL_EFFECT_UNKNOWN147,                 //    147
    SPELL_EFFECT_UNKNOWN148,                 //    148
    SPELL_EFFECT_UNKNOWN149,                 //    149
    SPELL_EFFECT_UNKNOWN150,                 //    150
    SPELL_EFFECT_UNKNOWN151,                 //    151
    SPELL_EFFECT_UNKNOWN152,                 //    152
    SPELL_EFFECT_SUMMON_TARGET,              //    153 ArcEmu
    SPELL_EFFECT_SUMMON_REFER_A_FRIEND,      //    154 ArcEmu
	SPELL_EFFECT_TAME_CREATURE,              //    155 ArcEmu
    SPELL_EFFECT_UNKNOWN156,                 //    156
    SPELL_EFFECT_UNKNOWN157,                 //    157
    SPELL_EFFECT_MILLING,                    //    158 ArcEmu
	SPELL_EFFECT_UNKNOWN159,                 //    159
	SPELL_EFFECT_UNKNOWN160,                 //    160
    SPELL_EFFECT_UNKNOWN161,                 //    161 - Double Spé
	SPELL_EFFECT_UNKNOWN162,                 //    162 - 
	SPELL_EFFECT_UNKNOWN163,                 //    163 - 
	SPELL_EFFECT_UNKNOWN164,                 //    164 - Double Spé
	SPELL_EFFECT_UNKNOWN165,                 //    165 - 
	SPELL_EFFECT_UNKNOWN166,                 //    166 - 
	SPELL_EFFECT_UNKNOWN167,                 //    167 - 
	SPELL_EFFECT_UNKNOWN168,                 //    168 -
	SPELL_EFFECT_UNKNOWN169,                 //    169 - 
	TOTAL_SPELL_EFFECTS                      //    170
};

// spell target system
#define TOTAL_SPELL_TARGET 110 // note: all spells with target type's > 104 are test spells

enum SPELL_ENTRY
{
    SPELL_ENTRY_Id,
    SPELL_ENTRY_School,
    SPELL_ENTRY_Category,
    SPELL_ENTRY_field4,
    SPELL_ENTRY_dispelType,
    SPELL_ENTRY_mechanics,
    SPELL_ENTRY_attributes,
    SPELL_ENTRY_attributesEx,
    SPELL_ENTRY_Flags3,
    SPELL_ENTRY_Flags4,
    SPELL_ENTRY_Flags5,
    SPELL_ENTRY_unk201_1,
    SPELL_ENTRY_shapeshiftMask,
    SPELL_ENTRY_UNK14,
    SPELL_ENTRY_Targets,
    SPELL_ENTRY_targetCreatureType,
    SPELL_ENTRY_requiresSpellFocus,
    SPELL_ENTRY_casterAuraState,
    SPELL_ENTRY_targetAuraState,
    SPELL_ENTRY_unk201_2,
    SPELL_ENTRY_unk201_3,
    SPELL_ENTRY_castingTimeIndex,
    SPELL_ENTRY_recoveryTime,
    SPELL_ENTRY_categoryRecoveryTime,
    SPELL_ENTRY_interruptFlags,
    SPELL_ENTRY_auraInterruptFlags,
    SPELL_ENTRY_channelInterruptFlags,
    SPELL_ENTRY_procFlags,
    SPELL_ENTRY_procChance,
    SPELL_ENTRY_procCharges,
    SPELL_ENTRY_maxLevel,
    SPELL_ENTRY_baseLevel,
    SPELL_ENTRY_spellLevel,
    SPELL_ENTRY_durationIndex,
    SPELL_ENTRY_powerType,
    SPELL_ENTRY_manaCost,
    SPELL_ENTRY_manaCostPerlevel,
    SPELL_ENTRY_manaPerSecond,
    SPELL_ENTRY_manaPerSecondPerLevel,
    SPELL_ENTRY_rangeIndex,
    SPELL_ENTRY_speed,
    SPELL_ENTRY_modalNextSpell,
    SPELL_ENTRY_cumulativeAura,
    SPELL_ENTRY_Totem_1,
    SPELL_ENTRY_Totem_2,
    SPELL_ENTRY_Reagent_1,
    SPELL_ENTRY_Reagent_2,
    SPELL_ENTRY_Reagent_3,
    SPELL_ENTRY_Reagent_4,
    SPELL_ENTRY_Reagent_5,
    SPELL_ENTRY_Reagent_6,
    SPELL_ENTRY_Reagent_7,
    SPELL_ENTRY_Reagent_8,
    SPELL_ENTRY_ReagentCount_1,
    SPELL_ENTRY_ReagentCount_2,
    SPELL_ENTRY_ReagentCount_3,
    SPELL_ENTRY_ReagentCount_4,
    SPELL_ENTRY_ReagentCount_5,
    SPELL_ENTRY_ReagentCount_6,
    SPELL_ENTRY_ReagentCount_7,
    SPELL_ENTRY_ReagentCount_8,
    SPELL_ENTRY_EquippedItemClass,
    SPELL_ENTRY_EquippedItemSubClass,
    SPELL_ENTRY_RequiredItemFlags,
    SPELL_ENTRY_Effect_1,
    SPELL_ENTRY_Effect_2,
    SPELL_ENTRY_Effect_3,
    SPELL_ENTRY_EffectDieSides_1,
    SPELL_ENTRY_EffectDieSides_2,
    SPELL_ENTRY_EffectDieSides_3,
    SPELL_ENTRY_EffectBaseDice_1,
    SPELL_ENTRY_EffectBaseDice_2,
    SPELL_ENTRY_EffectBaseDice_3,
    SPELL_ENTRY_EffectDicePerLevel_1,
    SPELL_ENTRY_EffectDicePerLevel_2,
    SPELL_ENTRY_EffectDicePerLevel_3,
    SPELL_ENTRY_EffectRealPointsPerLevel_1,
    SPELL_ENTRY_EffectRealPointsPerLevel_2,
    SPELL_ENTRY_EffectRealPointsPerLevel_3,
    SPELL_ENTRY_EffectBasePoints_1,
    SPELL_ENTRY_EffectBasePoints_2,
    SPELL_ENTRY_EffectBasePoints_3,
    SPELL_ENTRY_EffectMechanic_1,
    SPELL_ENTRY_EffectMechanic_2,
    SPELL_ENTRY_EffectMechanic_3,
    SPELL_ENTRY_EffectImplicitTargetA_1,
    SPELL_ENTRY_EffectImplicitTargetA_2,
    SPELL_ENTRY_EffectImplicitTargetA_3,
    SPELL_ENTRY_EffectImplicitTargetB_1,
    SPELL_ENTRY_EffectImplicitTargetB_2,
    SPELL_ENTRY_EffectImplicitTargetB_3,
    SPELL_ENTRY_EffectRadiusIndex_1,
    SPELL_ENTRY_EffectRadiusIndex_2, 
    SPELL_ENTRY_EffectRadiusIndex_3, 
    SPELL_ENTRY_EffectApplyAuraName_1,
    SPELL_ENTRY_EffectApplyAuraName_2,
    SPELL_ENTRY_EffectApplyAuraName_3,
    SPELL_ENTRY_EffectAmplitude_1,
    SPELL_ENTRY_EffectAmplitude_2,
    SPELL_ENTRY_EffectAmplitude_3,
    SPELL_ENTRY_Effectunknown_1,
    SPELL_ENTRY_Effectunknown_2,
    SPELL_ENTRY_Effectunknown_3,
    SPELL_ENTRY_EffectChainTarget_1,
    SPELL_ENTRY_EffectChainTarget_2,
    SPELL_ENTRY_EffectChainTarget_3,
    SPELL_ENTRY_EffectSpellGroupRelation_1,
    SPELL_ENTRY_EffectSpellGroupRelation_2,
    SPELL_ENTRY_EffectSpellGroupRelation_3,
    SPELL_ENTRY_EffectMiscValue_1,
    SPELL_ENTRY_EffectMiscValue_2,
    SPELL_ENTRY_EffectMiscValue_3,
    SPELL_ENTRY_EffectTriggerSpell_1,
    SPELL_ENTRY_EffectTriggerSpell_2,
    SPELL_ENTRY_EffectTriggerSpell_3,
    SPELL_ENTRY_EffectPointsPerComboPoint_1,
    SPELL_ENTRY_EffectPointsPerComboPoint_2,
    SPELL_ENTRY_EffectPointsPerComboPoint_3,
    SPELL_ENTRY_SpellVisual,
    SPELL_ENTRY_field114,
    SPELL_ENTRY_dummy,
    SPELL_ENTRY_CoSpell,
    SPELL_ENTRY_spellPriority,
    SPELL_ENTRY_Name,
    SPELL_ENTRY_NameAlt1,
    SPELL_ENTRY_NameAlt2,
    SPELL_ENTRY_NameAlt3,
    SPELL_ENTRY_NameAlt4,
    SPELL_ENTRY_NameAlt5,
    SPELL_ENTRY_NameAlt6,
    SPELL_ENTRY_NameAlt7,
    SPELL_ENTRY_NameAlt8,
    SPELL_ENTRY_NameAlt9,
    SPELL_ENTRY_NameAlt10,
    SPELL_ENTRY_NameAlt11,
    SPELL_ENTRY_NameAlt12,
    SPELL_ENTRY_NameAlt13,
    SPELL_ENTRY_NameAlt14,
    SPELL_ENTRY_NameAlt15,
    SPELL_ENTRY_NameFlags,
    SPELL_ENTRY_Rank,
    SPELL_ENTRY_RankAlt1,
    SPELL_ENTRY_RankAlt2,
    SPELL_ENTRY_RankAlt3,
    SPELL_ENTRY_RankAlt4,
    SPELL_ENTRY_RankAlt5,
    SPELL_ENTRY_RankAlt6,
    SPELL_ENTRY_RankAlt7,
    SPELL_ENTRY_RankAlt8,
    SPELL_ENTRY_RankAlt9,
    SPELL_ENTRY_RankAlt10,
    SPELL_ENTRY_RankAlt11,
    SPELL_ENTRY_RankAlt12,
    SPELL_ENTRY_RankAlt13,
    SPELL_ENTRY_RankAlt14,
    SPELL_ENTRY_RankAlt15,
    SPELL_ENTRY_RankFlags,
    SPELL_ENTRY_Description,
    SPELL_ENTRY_DescriptionAlt1,
    SPELL_ENTRY_DescriptionAlt2,
    SPELL_ENTRY_DescriptionAlt3,
    SPELL_ENTRY_DescriptionAlt4,
    SPELL_ENTRY_DescriptionAlt5,
    SPELL_ENTRY_DescriptionAlt6,
    SPELL_ENTRY_DescriptionAlt7,
    SPELL_ENTRY_DescriptionAlt8,
    SPELL_ENTRY_DescriptionAlt9,
    SPELL_ENTRY_DescriptionAlt10,
    SPELL_ENTRY_DescriptionAlt11,
    SPELL_ENTRY_DescriptionAlt12,
    SPELL_ENTRY_DescriptionAlt13,
    SPELL_ENTRY_DescriptionAlt14,
    SPELL_ENTRY_DescriptionAlt15,
    SPELL_ENTRY_DescriptionFlags,
    SPELL_ENTRY_BuffDescription,
    SPELL_ENTRY_BuffDescriptionAlt1,
    SPELL_ENTRY_BuffDescriptionAlt2,
    SPELL_ENTRY_BuffDescriptionAlt3,
    SPELL_ENTRY_BuffDescriptionAlt4,
    SPELL_ENTRY_BuffDescriptionAlt5,
    SPELL_ENTRY_BuffDescriptionAlt6,
    SPELL_ENTRY_BuffDescriptionAlt7,
    SPELL_ENTRY_BuffDescriptionAlt8,
    SPELL_ENTRY_BuffDescriptionAlt9,
    SPELL_ENTRY_BuffDescriptionAlt10,
    SPELL_ENTRY_BuffDescriptionAlt11,
    SPELL_ENTRY_BuffDescriptionAlt12,
    SPELL_ENTRY_BuffDescriptionAlt13,
    SPELL_ENTRY_BuffDescriptionAlt14,
    SPELL_ENTRY_BuffDescriptionAlt15,
    SPELL_ENTRY_buffdescflags,
    SPELL_ENTRY_ManaCostPercentage,
    SPELL_ENTRY_unkflags,
    SPELL_ENTRY_StartrecoveryTime,
    SPELL_ENTRY_StartRecoveryCategory,
    SPELL_ENTRY_SpellFamilyName,
    SPELL_ENTRY_SpellGroupType,
    SPELL_ENTRY_unkne,
    SPELL_ENTRY_MaxTargets,
    SPELL_ENTRY_defenseType,
    SPELL_ENTRY_FG,
    SPELL_ENTRY_FH,
    SPELL_ENTRY_effectChainAmplitude_1,
    SPELL_ENTRY_effectChainAmplitude_2,
    SPELL_ENTRY_effectChainAmplitude_3,
    SPELL_ENTRY_FL,
    SPELL_ENTRY_FM,
    SPELL_ENTRY_FN,
	SPELL_ENTRY_TotemCategory1,
	SPELL_ENTRY_TotemCategory2,
	SPELL_ENTRY_RequiredAreaID
};

// target type flags
enum SpellTargetTypes
{
    SPELL_TARGET_TYPE_NONE              = 0x01,
    SPELL_TARGET_TYPE_PROFESSION        = 0x02,
    SPELL_TARGET_TYPE_NONE1             = 0x04,
    SPELL_TARGET_TYPE_NONE2             = 0x08,
    SPELL_TARGET_TYPE_ENCHANTABLE_ITEM  = 0x10,
    SPELL_TARGET_TYPE_UNK               = 0x20,     // seems to be scripted stuff
    SPELL_TARGET_TYPE_UNK0              = 0x40,     // lots of spells interesting to research this one further
    SPELL_TARGET_TYPE_UNK1              = 0x80,     // something todo with scripted and GM stuff
    SPELL_TARGET_TYPE_UNK2              = 0x100,    // lots of spells interesting to research this one further...
    SPELL_TARGET_TYPE_PLAYER_CORPSE     = 0x200,
    SPELL_TARGET_TYPE_DEATHx            = 0x400,
    SPELL_TARGET_TYPE_NONE3             = 0x800,
    SPELL_TARGET_TYPE_NONE4             = 0x1000,
    SPELL_TARGET_TYPE_NONE5             = 0x2000,
    SPELL_TARGET_TYPE_GAME_OBJECTS      = 0x4000, // like chests and mining
    SPELL_TARGET_TYPE_DEATH             = 0x8000,
};

enum SpellTypes // SPELL_ENTRY_buffType
{
    SPELL_TYPE_NONE                 = 0x00000000,
    SPELL_TYPE_SEAL                 = 0x00000001,
    SPELL_TYPE_ASPECT               = 0x00000002,
    SPELL_TYPE_BLESSING             = 0x00000004,
    SPELL_TYPE_CURSE                = 0x00000008,
    SPELL_TYPE_STING                = 0x00000010,
    SPELL_TYPE_ARMOR                = 0x00000020,
    SPELL_TYPE_AURA                 = 0x00000040,
    //hmm these could be named simply incompatible spells. One active at a time
    SPELL_TYPE_MARK_GIFT            = 0x00000080,
    SPELL_TYPE_TRACK                = 0x00000100,
    SPELL_TYPE_HUNTER_TRAP          = 0x00000200,
    SPELL_TYPE_MAGE_INTEL           = 0x00000400,
    SPELL_TYPE_MAGE_MAGI            = 0x00000800,
    SPELL_TYPE_MAGE_WARDS           = 0x00001000,
    SPELL_TYPE_PRIEST_SH_PPROT      = 0x00002000,
    SPELL_TYPE_SHIELD               = 0x00004000,
    SPELL_TYPE_FORTITUDE            = 0x00008000,
    SPELL_TYPE_SPIRIT               = 0x00010000,
    SPELL_TYPE_MAGE_AMPL_DUMP       = 0x00020000,
    SPELL_TYPE_WARLOCK_IMMOLATE     = 0x00040000, //maybe there is a better way to trigger the aura state for immolate spell
    SPELL_TYPE_ELIXIR_BATTLE		= 0x00080000, 
    SPELL_TYPE_ELIXIR_GUARDIAN      = 0x00100000, 
    SPELL_TYPE_ELIXIR_FLASK         = SPELL_TYPE_ELIXIR_BATTLE | SPELL_TYPE_ELIXIR_GUARDIAN, //weee, this contains both battle and guardian elixirs ;)
    SPELL_TYPE_HUNTER_MARK			= 0x00200000,
    SPELL_TYPE_WARRIOR_SHOUT        = 0x00400000,
	SPELL_TYPE_DK_PRESENCE          = 0x00800000,
	SPELL_TYPE_JUDGEMENT			= 0x01000000,
	SPELL_TYPE_HASTE				= 0x02000000,
};

enum SpellIsFlags //Note Randdrick : Ascent 313 - Doit être valide pour la 3.09. En test.
{
    SPELL_FLAG_IS_DAMAGING				= 0x00000001,
    SPELL_FLAG_IS_HEALING				= 0x00000002,
    SPELL_FLAG_IS_TARGETINGSTEALTHED	= 0x00000004,
    SPELL_FLAG_IS_REQUIRECOOLDOWNUPDATE	= 0x00000008, //it started with rogue cold blood but i'm sure others will come
    SPELL_FLAG_IS_POISON				= 0x00000010, //rogue has a few spells that can stack so can't use the spell_type enum ;)
    SPELL_FLAG_IS_FINISHING_MOVE		= 0x00000020, //rogue has a few spells that can stack so can't use the spell_type enum ;)
    SPELL_FLAG_IS_NOT_USING_DMG_BONUS	= 0x00000040,
    SPELL_FLAG_IS_CHILD_SPELL			= 0x00000080, //auras proc auras that have same name, these should not remove mother aura when adding to target
    SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET		= 0x00000100, //we should cast these on pet too
    SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER	= 0x00000200, //we should cast these on owner too
    SPELL_FLAG_IS_EXPIREING_WITH_PET	= 0x00000400, //when pet dies, we remove this too
    SPELL_FLAG_IS_EXPIREING_ON_PET		= 0x00000800, //when pet is summoned
	SPELL_FLAG_IS_DISPEL_SPELL			= 0x00001000,
	SPELL_FLAG_CAN_BE_REFLECTED			= 0x00002000,
	SPELL_FLAG_IS_HEALING_SPELL			= 0x00004000,
	SPELL_FLAG_IS_HEALING_MANA_SPELL	= 0x00008000,
	SPELL_FLAG_CANNOT_PROC_ON_SELF		= 0x00010000,
	SPELL_FLAG_IS_FLYING				= 0x00020000,
	SPELL_FLAG_IS_FORCEDDEBUFF			= 0x00040000,
	SPELL_FLAG_IS_FORCEDBUFF			= 0x00080000,
	SPELL_FLAG_ON_ONLY_ONE_TARGET		= 0x00100000,
	SPELL_FLAG_IS_NOT_RESISTABLE		= 0x00200000,
	SPELL_FLAG_PIERCES_ABSORBTION_EFF	= 0x00400000,
	SPELL_FLAG_CASTED_ON_FRIENDS		= 0x00800000,
	SPELL_FLAG_CASTED_ON_ENEMIES		= 0x01000000,
};

enum PoisonTypes
{
	POISON_TYPE_DEADLY			= 1,
	POISON_TYPE_WOUND			= 2,
	POISON_TYPE_INSTANT			= 3,
	POISON_TYPE_MIND_NUMBING	= 4,
	POISON_TYPE_CRIPPLING		= 5,
	POISON_TYPE_SCORPID			= 6,

};

enum SpellCoefficientsFlags
{
	SPELL_FLAG_IS_DOT_OR_HOT_SPELL		= 0x00000001, //Damage over Time or Healing over Time Spells
	SPELL_FLAG_IS_DD_OR_DH_SPELL		= 0x00000002, //Direct Damage or Direct Healing Spells
	SPELL_FLAG_IS_DD_DH_DOT_SPELL		= SPELL_FLAG_IS_DOT_OR_HOT_SPELL | SPELL_FLAG_IS_DD_OR_DH_SPELL, //DoT+(DD|DH) Spells
	SPELL_FLAG_AOE_SPELL				= 0x00000004, //AoE Spells
	SPELL_FLAG_ADITIONAL_EFFECT			= 0x00000008, //Spells with aditional effect not DD or DoT or HoT
};

enum AreaAuraTargets
{
	AA_TARGET_PARTY				= 0x01,
	AA_TARGET_RAID				= 0x02,
	AA_TARGET_ALLFRIENDLY		= 0x04,
	AA_TARGET_ALLENEMIES		= 0x08,
	AA_TARGET_PET				= 0x10,
	AA_TARGET_NOTSELF			= 0x20,
};

enum SpellFamilyNames
{
	SPELLFAMILY_GENERIC		= 0,
	SPELLFAMILY_UNK1,
	SPELLFAMILY_MAGE		= 3,
	SPELLFAMILY_WARRIOR,
	SPELLFAMILY_WARLOCK,
	SPELLFAMILY_PRIEST,
	SPELLFAMILY_DRUID,
	SPELLFAMILY_ROGUE,
	SPELLFAMILY_HUNTER,
	SPELLFAMILY_PALADIN,
	SPELLFAMILY_SHAMAN,
	SPELLFAMILY_UNK2,
	SPELLFAMILY_POTION,
	SPELLFAMILY_DEATHKNIGHT	= 15,
	SPELLFAMILY_PET			= 17
};

ASCENT_INLINE bool CanAgroHash(uint32 spellhashname)
{
    // SPELL_HASH_HUNTER_S_MARK		0xFF89ABD2	// 1130 _Rank 1
    if (spellhashname == SPELL_HASH_HUNTER_S_MARK) // 34832 SPELL_HASH_HUNTER_S_MARK) //hunter's mark
        return false;
    else
        return true;
}

/************************************************************************/
/* IsDamagingSpell, this function seems slow, its only used rarely      */
/************************************************************************/
ASCENT_INLINE bool IsDamagingSpell(SpellEntry *sp)
{
    switch (sp->Effect[0])
    {
        case SPELL_EFFECT_SCHOOL_DAMAGE:
        case SPELL_EFFECT_ENVIRONMENTAL_DAMAGE:
        case SPELL_EFFECT_HEALTH_LEECH:
        case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
        case SPELL_EFFECT_ADD_EXTRA_ATTACKS:
        case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
        case SPELL_EFFECT_POWER_BURN:
        case SPELL_EFFECT_ATTACK:
            return true;
    }
    switch (sp->Effect[1])
    {
        case SPELL_EFFECT_SCHOOL_DAMAGE:
        case SPELL_EFFECT_ENVIRONMENTAL_DAMAGE:
        case SPELL_EFFECT_HEALTH_LEECH:
        case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
        case SPELL_EFFECT_ADD_EXTRA_ATTACKS:
        case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
        case SPELL_EFFECT_POWER_BURN:
        case SPELL_EFFECT_ATTACK:
            return true;
    }
    switch (sp->Effect[2])
    {
        case SPELL_EFFECT_SCHOOL_DAMAGE:
        case SPELL_EFFECT_ENVIRONMENTAL_DAMAGE:
        case SPELL_EFFECT_HEALTH_LEECH:
        case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
        case SPELL_EFFECT_ADD_EXTRA_ATTACKS:
        case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
        case SPELL_EFFECT_POWER_BURN:
        case SPELL_EFFECT_ATTACK:
            return true;
    }
    if( sp->Effect[0]==SPELL_EFFECT_APPLY_AURA ||
       sp->Effect[0]==SPELL_EFFECT_APPLY_AREA_AURA)
    {
        switch (sp->EffectApplyAuraName[0])
        {
		 case SPELL_AURA_PERIODIC_DAMAGE:            //   3
            case SPELL_AURA_PROC_TRIGGER_DAMAGE:     //  43
			case SPELL_AURA_PERIODIC_DAMAGE_PERCENT: //  89
			case SPELL_AURA_POWER_BURN:              // 162
                return true;
        }
    }
    if( sp->Effect[1]==SPELL_EFFECT_APPLY_AURA ||
        sp->Effect[1]==SPELL_EFFECT_APPLY_AREA_AURA)
    {
        switch (sp->EffectApplyAuraName[1])
        {
            case SPELL_AURA_PERIODIC_DAMAGE:        //   3
            case SPELL_AURA_PROC_TRIGGER_DAMAGE:    //  43
            case SPELL_AURA_PERIODIC_DAMAGE_PERCENT://  89
			case SPELL_AURA_POWER_BURN:             // 162
                return true;
        }
    }
    if( sp->Effect[2]==SPELL_EFFECT_APPLY_AURA ||
        sp->Effect[2]==SPELL_EFFECT_APPLY_AREA_AURA)
    {
        switch (sp->EffectApplyAuraName[2])
        {
           case SPELL_AURA_PERIODIC_DAMAGE:        //   3
           case SPELL_AURA_PROC_TRIGGER_DAMAGE:    //  43
           case SPELL_AURA_PERIODIC_DAMAGE_PERCENT://  89
		   case SPELL_AURA_POWER_BURN:             // 162
                return true;
        }
    }
    return false;
}

ASCENT_INLINE bool IsHealingSpell(SpellEntry *sp)
{
    switch( sp->Effect[0] )
    {
        case SPELL_EFFECT_HEALTH_LEECH:
        case SPELL_EFFECT_HEAL:
        case SPELL_EFFECT_HEAL_MAX_HEALTH:
            return true;
		default: break;
    }
    switch( sp->Effect[1] )
    {
        case SPELL_EFFECT_HEALTH_LEECH:
        case SPELL_EFFECT_HEAL:
        case SPELL_EFFECT_HEAL_MAX_HEALTH:
            return true;
		default: break;
    }
    switch( sp->Effect[2] )
    {
        case SPELL_EFFECT_HEALTH_LEECH:
        case SPELL_EFFECT_HEAL:
        case SPELL_EFFECT_HEAL_MAX_HEALTH:
            return true;
		default: break;
    }
    if( sp->Effect[0] == SPELL_EFFECT_APPLY_AURA ||
		sp->Effect[0] == SPELL_EFFECT_APPLY_AREA_AURA )
    {
        switch( sp->EffectApplyAuraName[0] )
        {
            case 8://SPELL_AURA_PERIODIC_HEAL:
            case 62://SPELL_AURA_PERIODIC_HEALTH_FUNNEL:
                return true;
			default: break;
        }
    }
    if( sp->Effect[1] == SPELL_EFFECT_APPLY_AURA ||
        sp->Effect[1] == SPELL_EFFECT_APPLY_AREA_AURA )
    {
        switch (sp->EffectApplyAuraName[1])
        {
            case 8://SPELL_AURA_PERIODIC_HEAL:
            case 62://SPELL_AURA_PERIODIC_HEALTH_FUNNEL:
                return true;
			default: break;
        }
    }
    if( sp->Effect[2] == SPELL_EFFECT_APPLY_AURA ||
        sp->Effect[2] == SPELL_EFFECT_APPLY_AREA_AURA )
    {
        switch( sp->EffectApplyAuraName[2] )
        {
		  case SPELL_AURA_PERIODIC_HEAL:
          case SPELL_AURA_PERIODIC_HEALTH_FUNNEL:
                return true;
			default: break;
        }
    }
	//flash of light, holy light uses scripted effect which is not neceserally heal spell
	if( sp->NameHash == SPELL_HASH_HOLY_LIGHT || sp->NameHash == SPELL_HASH_FLASH_OF_LIGHT  )
		return true;
	// SPELL_HASH_IMPROVED_HOLY_LIGHT - SPELL_HASH_HOLY_LIGHT_CRIT
    return false;
}

ASCENT_INLINE bool IsInrange(LocationVector & location, Object * o, float square_r)
{
    float r = o->GetDistanceSq(location);
    return ( r<=square_r);
}

ASCENT_INLINE bool IsInrange(float x1,float y1, float z1, Object * o,float square_r)
{
    float r = o->GetDistanceSq(x1, y1, z1);
    return ( r<=square_r);
}

ASCENT_INLINE bool IsInrange(float x1,float y1, float z1,float x2,float y2, float z2,float square_r)
{
    float t;
    float r;
    t=x1-x2;
    r=t*t;
    t=y1-y2;
    r+=t*t;
    t=z1-z2;
    r+=t*t;
    return ( r<=square_r);
}
   
ASCENT_INLINE bool IsInrange(Object * o1,Object * o2,float square_r)
{
    return IsInrange(o1->GetPositionX(),o1->GetPositionY(),o1->GetPositionZ(),
        o2->GetPositionX(),o2->GetPositionY(),o2->GetPositionZ(),square_r);
}

ASCENT_INLINE bool TargetTypeCheck(Object *obj,uint32 ReqCreatureTypeMask)
{
	if( !ReqCreatureTypeMask )
		return true;

	if( obj->GetTypeId() == TYPEID_UNIT )
	{
		CreatureInfo* inf = static_cast< Creature* >( obj )->GetCreatureName();
		if( inf == NULL || !( 1 << ( inf->Type - 1 ) & ReqCreatureTypeMask ) )
			return false;
	}
	else if(obj->GetTypeId() == TYPEID_PLAYER && !(UNIT_TYPE_HUMANOID_BIT & ReqCreatureTypeMask))
		return false;
	else return false;//omg, how in the hack did we cast it on a GO ? But who cares ?
	return true;
}

class SpellCastTargets
{
public:
	void write ( StackPacket & data);
    void write ( WorldPacket & data);
	void read ( WorldPacket & data, Object* obj );
	void read ( WorldPacket & data, uint64 caster );	

 

    SpellCastTargets()
	{
     m_targetMask = 0;
	 m_targetMaskExtended = 0;
	 m_target             = NULL;
//	 m_unitTarget         = 0;
//	 m_itemTarget         = 0;
	 m_srcX = 0;
	 m_srcY = 0;
	 m_srcZ = 0;
     m_destX = 0;
	 m_destY = 0;
	 m_destZ = 0;
     m_strTarget = ""; 
	}

    SpellCastTargets(uint16 TargetMask, Object* target, float srcX, float srcY,float srcZ, float destX, float destY, float destZ)
	{
	 //	: m_targetMask(TargetMask), m_targetMaskExtended(0),
     //    m_target(target),m_itemTarget(0),m_unitTarget(0), m_srcX(srcX), m_srcY(srcY), m_srcZ(srcZ), m_destX(destX), m_destY(destY), m_destZ(destZ) {}
     m_targetMask         = TargetMask;
	 m_targetMaskExtended = 0;
	 m_target             = target;
//	 m_unitTarget         = 0;
//	 m_itemTarget         = 0;
	 m_srcX               = srcX;
	 m_srcY               = srcY;
	 m_srcZ               = srcZ;
     m_destX              = destX;
	 m_destY              = destY;
	 m_destZ              = destZ;
	 m_strTarget = ""; //((target->GetObjectName()) ? (target->GetObjectName()) : "Inconnu") ;
	}

/*   SpellCastTargets(uint16 TargetMask, uint64 unitTarget, float srcX, float srcY,float srcZ, float destX, float destY, float destZ)
   {
	   //: m_targetMask(TargetMask), m_targetMaskExtended(0),m_target(NULL),
       // m_unitTarget(unitTarget),m_itemTarget(0), m_srcX(srcX), m_srcY(srcY), m_srcZ(srcZ), m_destX(destX), m_destY(destY), m_destZ(destZ) {}
	 m_targetMask         = TargetMask;
	 m_targetMaskExtended = 0;
	 m_target             = NULL;
	 m_unitTarget         = unitTarget;
	 m_itemTarget         = 0;
	 m_srcX               = srcX;
	 m_srcY               = srcY;
	 m_srcZ               = srcZ;
     m_destX              = destX;
	 m_destY              = destY;
	 m_destZ              = destZ;
	 m_strTarget = "";
   }*/

    SpellCastTargets(Object* target) 
	{
     // r372: Gestion de la cible (Brz)
	 // Cas ou on passe juste le pointeur pour faciliter l'init.
	 // NB: Le GenerateTarget doit etre utilisé apres l'appel dans ce cas
	 if(target)
	 {
		if(target->IsPlayer())    m_targetMask = TARGET_FLAG_SELF;
		else if(target->IsUnit()) m_targetMask = TARGET_FLAG_UNIT;
		else if(target->IsItem()) m_targetMask = TARGET_FLAG_ITEM;
		else if(target->IsGO())   m_targetMask = TARGET_FLAG_OBJECT;
		else                      m_targetMask = 0;
	 }
	 else m_targetMask = 0;

	 m_targetMaskExtended = 0;
	 m_target             = target;
//	 m_unitTarget         = 0;
//	 m_itemTarget         = 0;
	 m_srcX               = 0;
	 m_srcY               = 0;
	 m_srcZ               = 0;
     m_destX              = 0;
	 m_destY              = 0;
	 m_destZ              = 0;
	 m_strTarget = "";

	}
		
// ----- New spell System
    /*SpellCastTargets() : m_targetMask(0), m_unitTarget(0), m_itemTarget(0), m_srcX(0), m_srcY(0), m_srcZ(0),
        m_destX(0), m_destY(0), m_destZ(0) {}*/

 /*  SpellCastTargets(uint16 TargetMask, uint64 unitTarget, uint64 itemTarget, float srcX, float srcY,float srcZ, float destX, float destY, float destZ)
   {
	   //: m_targetMask(TargetMask),m_target(NULL), m_unitTarget(unitTarget),
       // m_itemTarget(itemTarget), m_srcX(srcX), m_srcY(srcY), m_srcZ(srcZ), m_destX(destX), m_destY(destY), m_destZ(destZ) {}
	 m_targetMask         = TargetMask;
	 m_targetMaskExtended = 0;
	 m_target             = NULL;
	 m_unitTarget         = unitTarget;
	 m_itemTarget         = itemTarget;
	 m_srcX               = srcX;
	 m_srcY               = srcY;
	 m_srcZ               = srcZ;
     m_destX              = destX;
	 m_destY              = destY;
	 m_destZ              = destZ;
	 m_strTarget = "";
   }*/

  /*  SpellCastTargets(uint64 unitTarget)
	{
		//: m_targetMask(TARGET_FLAG_UNIT), m_target(NULL),m_unitTarget(unitTarget), m_itemTarget(0),
        //m_srcX(0), m_srcY(0), m_srcZ(0), m_destX(0), m_destY(0), m_destZ(0) {}
	 m_targetMask         = TARGET_FLAG_UNIT;
	 m_targetMaskExtended = 0;
	 m_target             = NULL;
	 m_unitTarget         = unitTarget;
	 m_itemTarget         = 0;
	 m_srcX               = 0;
	 m_srcY               = 0;
	 m_srcZ               = 0;
     m_destX              = 0;
	 m_destY              = 0;
	 m_destZ              = 0;
	 m_strTarget = "";
	}*/

    SpellCastTargets(WorldPacket & data, uint64 caster)
		//: m_targetMask(0),m_target(NULL), m_unitTarget(0), m_itemTarget(0), 
		//m_srcX(0), m_srcY(0), m_srcZ(0),m_destX(0), m_destY(0), m_destZ(0)
    {
	 m_targetMask         = 0;
	 m_targetMaskExtended = 0;
	 m_target             = NULL;
//	 m_unitTarget         = 0;
//	 m_itemTarget         = 0;
	 m_srcX               = 0;
	 m_srcY               = 0;
	 m_srcZ               = 0;
     m_destX              = 0;
	 m_destY              = 0;
	 m_destZ              = 0;
	 m_strTarget = "";

     read(data, caster);
    }
// ------

	SpellCastTargets(WorldPacket & data, Object* obj) 
	{ 
	 m_targetMask         = 0;
	 m_targetMaskExtended = 0;
	 m_target             = NULL;
//	 m_unitTarget         = 0;
//	 m_itemTarget         = 0;
	 m_srcX               = 0;
	 m_srcY               = 0;
	 m_srcZ               = 0;
     m_destX              = 0;
	 m_destY              = 0;
	 m_destZ              = 0;
	 m_strTarget = "";

	 read(data, obj); 
	}

    SpellCastTargets& operator=(const SpellCastTargets &target)
    {
        m_target = target.m_target;		
//		m_unitTarget = target.m_unitTarget;
//		m_itemTarget = target.m_itemTarget;

        m_srcX = target.m_srcX;
        m_srcY = target.m_srcY;
        m_srcZ = target.m_srcZ;

        m_destX = target.m_destX;
        m_destY = target.m_destY;
        m_destZ = target.m_destZ;

        m_strTarget = target.m_strTarget;

        m_targetMask = target.m_targetMask;
		m_targetMaskExtended = target.m_targetMaskExtended;
        return *this;
    }

    uint16 m_targetMask;
    uint16 m_targetMaskExtended;			// this could be a 32 also
	Object* m_target;
	//uint64 m_unitTarget; // Debug, a virer, tt est géré via m_target (Branruz)
	//uint64 m_itemTarget; // Debug, a virer (Branruz)
	float m_srcX, m_srcY, m_srcZ;
    float m_destX, m_destY, m_destZ;
    std::string m_strTarget;

};

enum SpellState
{
    SPELL_STATE_NULL      = 0,
    SPELL_STATE_PREPARING = 1,
    SPELL_STATE_CASTING   = 2,
    SPELL_STATE_FINISHED  = 3,
    SPELL_STATE_IDLE      = 4
};

enum ShapeshiftForm
{
	FORM_NORMAL             = 0,
	FORM_CAT                = 1,
	FORM_TREE               = 2,
	FORM_TRAVEL             = 3,
	FORM_AQUA               = 4,
	FORM_BEAR               = 5,
	FORM_AMBIENT            = 6,
	FORM_GHOUL              = 7,
	FORM_DIREBEAR           = 8,
	// Taxi ??              = 9,
	FORM_CREATUREBEAR       = 14,
	FORM_GHOSTWOLF          = 16,
	FORM_BATTLESTANCE       = 17,
	FORM_DEFENSIVESTANCE    = 18,
	FORM_BERSERKERSTANCE    = 19,
	FORM_ZOMBIE				= 21, //2097152
	FORM_SWIFT              = 27,
	FORM_SHADOW             = 28,
	FORM_FLIGHT             = 29,
	FORM_STEALTH            = 30,
	FORM_MOONKIN            = 31,
	FORM_SPIRITOFREDEMPTION = 32,
};
/*
enum DISPEL_TYPE
{
    DISPEL_ZGTRINKETS = -1,
    DISPEL_NULL,
    DISPEL_MAGIC,
    DISPEL_CURSE,
    DISPEL_DISEASE,
    DISPEL_POISON,
    DISPEL_STEALTH,
    DISPEL_INVISIBILTY,
    DISPEL_ALL,
    DISPEL_SPECIAL_NPCONLY,
    DISPEL_ENRAGE,          //DISPEL_FRENZY,
	NUM_DISPELS,
};*/

enum DISPEL_MECHANIC_TYPE
{
    DISPEL_MECHANIC_CHARM       = 1,
    DISPEL_MECHANIC_FEAR        = 5,
    DISPEL_MECHANIC_ROOT        = 7,
    DISPEL_MECHANIC_SLEEP       = 10,
    DISPEL_MECHANIC_SNARE       = 11,
    DISPEL_MECHANIC_STUN        = 12,
    DISPEL_MECHANIC_KNOCKOUT    = 14,
    DISPEL_MECHANIC_BLEED       = 15,
    DISPEL_MECHANIC_POLYMORPH   = 17,
    DISPEL_MECHANIC_BANISH      = 18,
    DISPEL_MECHANIC_MOUNTED     = 21,
};
/*
enum MECHANICS
{
    MECHANIC_CHARMED = 1,
    MECHANIC_DISORIENTED, // 2
    MECHANIC_DISARMED, // 3
    MECHANIC_DISTRACED, // 4
    MECHANIC_FLEEING, // 5
    MECHANIC_CLUMSY, // 6
    MECHANIC_ROOTED, // 7
    MECHANIC_PACIFIED, // 8
    MECHANIC_SILENCED, // 9
    MECHANIC_ASLEEP, // 10
    MECHANIC_ENSNARED, // 11
    MECHANIC_STUNNED, // 12
    MECHANIC_FROZEN, // 13
    MECHANIC_INCAPACIPATED, // 14
    MECHANIC_BLEEDING, // 15
    MECHANIC_HEALING, // 16
    MECHANIC_POLYMORPHED, // 17
    MECHANIC_BANISHED, // 18
    MECHANIC_SHIELDED, // 19
    MECHANIC_SHACKLED, // 20
    MECHANIC_MOUNTED, // 21
    MECHANIC_SEDUCED, // 22
    MECHANIC_TURNED, // 23
    MECHANIC_HORRIFIED, // 24
    MECHANIC_INVULNARABLE, // 25
    MECHANIC_INTERRUPTED, // 26
    MECHANIC_DAZED, // 27
	MECHANIC_UNK1, // 28, fill in please
	MECHANIC_UNK2, // 29, fill in please
	MECHANIC_SAPPED, // 30
	MECHANIC_ENRAGED, //31
	MECHANIC_SIZE, // padding for array
};
*/
typedef enum {
   EFF_TARGET_NONE										= 0, 
   EFF_TARGET_SELF										= 1,
   EFF_TARGET_AoF 	/*? Area of Fire ?*/  		        = 2, // 30235 47688 47737 52671 54215 59834 63030 71891, pas un de plus, + selection
   EFF_TARGET_FRIENDLY                                  = 3, // 22838 36346 42885 42886 42887 pas un de plus
   EFF_TARGET_UNK4                                      = 4,
   EFF_TARGET_PET										= 5,
   EFF_TARGET_SINGLE_ENEMY								= 6,
   EFF_TARGET_SCRIPTED_TARGET							= 7,
   EFF_TARGET_ALL_TARGETABLE_AROUND_LOCATION_IN_RADIUS  = 8,
   EFF_TARGET_HEARTSTONE_LOCATION						= 9,
   EFF_TARGET_ALL_ENEMY_IN_AREA							= 15,
   EFF_TARGET_ALL_ENEMY_IN_AREA_INSTANT					= 16,
   EFF_TARGET_TELEPORT_LOCATION							= 17,
   EFF_TARGET_LOCATION_TO_SUMMON						= 18,
   // 19 : non trouvé 335.12340
   EFF_TARGET_ALL_PARTY_AROUND_CASTER					= 20,
   EFF_TARGET_SINGLE_FRIEND								= 21,
   EFF_TARGET_ALL_ENEMIES_AROUND_CASTER					= 22,
   EFF_TARGET_GAMEOBJECT								= 23,
   EFF_TARGET_IN_FRONT_OF_CASTER						= 24,
   EFF_TARGET_TO_SELECT  								= 25, // Meilleur nom, anciennement EFF_TARGET_DUEL (Brz)
   EFF_TARGET_GAMEOBJECT_ITEM							= 26,
   EFF_TARGET_PET_MASTER								= 27,
   EFF_TARGET_ALL_ENEMY_IN_AREA_CHANNELED				= 28,
   EFF_TARGET_ALL_PARTY_IN_AREA_CHANNELED				= 29,
   EFF_TARGET_ALL_FRIENDLY_IN_AREA						= 30,
   EFF_TARGET_ALL_TARGETABLE_AROUND_LOCATION_IN_RADIUS_OVER_TIME	= 31,
   EFF_TARGET_MINION									= 32,
   EFF_TARGET_ALL_PARTY_IN_AREA							= 33,
   EFF_TARGET_SINGLE_PARTY								= 35,
   EFF_TARGET_PET_SUMMON_LOCATION						= 36,
   EFF_TARGET_ALL_PARTY									= 37,
   EFF_TARGET_SCRIPTED_OR_SINGLE_TARGET					= 38,
   EFF_TARGET_SELF_FISHING								= 39,
   EFF_TARGET_SCRIPTED_GAMEOBJECT						= 40,
   EFF_TARGET_TOTEM_EARTH								= 41,
   EFF_TARGET_TOTEM_WATER								= 42,
   EFF_TARGET_TOTEM_AIR									= 43,
   EFF_TARGET_TOTEM_FIRE								= 44,
   EFF_TARGET_CHAIN										= 45,
   EFF_TARGET_SCIPTED_OBJECT_LOCATION					= 46,
   EFF_TARGET_DYNAMIC_OBJECT							= 47,//not sure exactly where is used
   EFF_TARGET_MULTIPLE_SUMMON_LOCATION					= 48,
   EFF_TARGET_MULTIPLE_SUMMON_PET_LOCATION				= 49,
   EFF_TARGET_SUMMON_LOCATION							= 50,
   EFF_TARGET_CALIRI_EGS								= 51,
   EFF_TARGET_LOCATION_NEAR_CASTER						= 52,
   EFF_TARGET_CURRENT_SELECTION							= 53,
   EFF_TARGET_TARGET_AT_ORIENTATION_TO_CASTER			= 54,
   //EFF_TARGET_LOCATION_INFRONT_CASTER					= 55, n'existe plus en 335.12340
   EFF_TARGET_AOE                                       = 56,
   EFF_TARGET_PARTY_MEMBER								= 57,
   EFF_TARGET_PESTE_EMETIQUE                            = 58, // seulement 2 spells 30080 et 62500 Peste emetique et sdfds
   EFF_TARGET_TARGET_FOR_VISUAL_EFFECT					= 59,
   EFF_TARGET_SCRIPTED_TARGET2							= 60,
   EFF_TARGET_AREAEFFECT_PARTY_AND_CLASS				= 61,
   //EFF_TARGET_PRIEST_CHAMPION							= 62, //wtf ? N'existe plus en 335.12340
   EFF_TARGET_NATURE_SUMMON_LOCATION					= 63, 
   EFF_TARGET_UNK64                                     = 64,
   EFF_TARGET_BEHIND_TARGET_LOCATION					= 65, // 3 Spells 43423 52277 56732
   EFF_TARGET_BEHIND_TARGET_LOCATION2                   = 66, // idem 3 spells (pas les memes ;) )
   EFF_TARGET_BEHIND_TARGET_LOCATION3                   = 67, // idem 3 spells (pas les memes ;) )
   EFF_TARGET_WYRMREST_DEFENDER                         = 68, // 49207 : Defending Wyrmrest Temple: Summon Wyrmrest Defender
   EFF_TARGET_FOOTMAN                                   = 69, // 48655 : The Perfect Dissemblance: Summon Player's Footman & Credit Credit
   EFF_TARGET_JOUTE                                     = 70, // 45105 : Joute
   // 71 n'existe pas en 335.12340
   EFF_TARGET_MULTIPLE_GUARDIAN_SUMMON_LOCATION			= 72,
   EFF_TARGET_NETHETDRAKE_SUMMON_LOCATION				= 73,
   EFF_TARGET_SCRIPTED_LOCATION							= 74,
   EFF_TARGET_LOCATION_INFRONT_CASTER_AT_RANGE			= 75, // 2 Spells 47690 67005
   EFF_TARGET_ENEMYS_IN_ARE_CHANNELED_WITH_EXCEPTIONS	= 76,
   EFF_TARGET_SELECTED_ENEMY_CHANNELED					= 77,
   EFF_TARGET_EVENTAIL_DE_COUTEAUX                      = 78, // 61739
   EFF_TARGET_UNK79  									= 79, // 48757 54994 61740 71077
   EFF_TARGET_UNK80										= 80, //targetted aoe summon
   EFF_TARGET_UNK81                                     = 81, 
   EFF_TARGET_EVENTAIL_DE_COUTEAUX2                     = 82, // 61746
   EFF_TARGET_EVENTAIL_DE_COUTEAUX3                     = 83, // 61741
   EFF_TARGET_EVENTAIL_DE_COUTEAUX4                     = 84, // 61744
   EFF_TARGET_EVENTAIL_DE_COUTEAUX5                     = 85, // 61743 + 40967 
   EFF_TARGET_SELECTED_ENEMY_DEADLY_POISON				= 86,
   EFF_TARGET_UNK87										= 87, // just seems to be a simple aoe target, with a little circle
   EFF_TARGET_UNK88										= 88, // even smaller aoe circle
   EFF_TARGET_LANCER_DES_TRUCS							= 89, // Lancer des trucs
   EFF_TARGET_UNK90										= 90, // target non-combat pet :P
   EFF_TARGET_LACHER_LE_COR                             = 91, // 56890 Lacher le Cor de fureur élémentaire
   EFF_TARGET_UNK92										= 92,
   // 93 n'existe pas en 335.12340
   EFF_TARGET_UNK94  									= 94,
   EFF_TARGET_UNK95  									= 95,
   EFF_TARGET_UNK96  									= 96,
   EFF_TARGET_UNK97 									= 97,
   // 98 n'existe pas en 335.12340
   EFF_TARGET_UNK99  									= 99,
   // 100 à 103 n'existe pas en 335.12340
   EFF_TARGET_UNK104  									= 104,
   // 105
   EFF_TARGET_BLIZZARD 									= 106, // 70131 70598 Blizzard surpuissant - Fureur de Sindragosa
   // 107
   EFF_TARGET_GGOODMANTEST2								= 108, // 23618 GGOODMANTEST2
   // 109
   EFF_TARGET_BOIRE     								= 110,// 42436 49299 Boire - Racer Slam, find Target
   EFF_TARGET_MAX
} SpellEffectTarget;

ASCENT_INLINE bool IsFlyingSpell(SpellEntry *sp)
{
	if( sp->EffectApplyAuraName[0] == SPELL_AURA_FLYING_SELF || 
		sp->EffectApplyAuraName[1] == SPELL_AURA_FLYING_SELF || 
		sp->EffectApplyAuraName[2] == SPELL_AURA_FLYING_SELF || 

		sp->EffectApplyAuraName[0] == SPELL_AURA_FLYING_MOUNT || 
		sp->EffectApplyAuraName[1] == SPELL_AURA_FLYING_MOUNT || 
		sp->EffectApplyAuraName[2] == SPELL_AURA_FLYING_MOUNT || 

		sp->EffectApplyAuraName[0] == SPELL_AURA_FLYING_SPEED || 
		sp->EffectApplyAuraName[1] == SPELL_AURA_FLYING_SPEED || 
		sp->EffectApplyAuraName[2] == SPELL_AURA_FLYING_SPEED || 

		sp->NameHash == SPELL_HASH_SWIFT_FLIGHT_FORM || 
		sp->NameHash == SPELL_HASH_FLIGHT_FORM ||
		sp->NameHash == SPELL_HASH_MAGNIFICENT_FLYING_CARPET ||
		sp->NameHash == SPELL_HASH_FLYING_CARPET )
	{
		return true;
	}

	return false;
}
ASCENT_INLINE bool IsTargetingStealthed(SpellEntry *sp)
{
	if(                           
		sp->EffectImplicitTargetA[0]==EFF_TARGET_ALL_TARGETABLE_AROUND_LOCATION_IN_RADIUS_OVER_TIME ||
		sp->EffectImplicitTargetA[1]==EFF_TARGET_ALL_TARGETABLE_AROUND_LOCATION_IN_RADIUS_OVER_TIME ||
		sp->EffectImplicitTargetA[2]==EFF_TARGET_ALL_TARGETABLE_AROUND_LOCATION_IN_RADIUS_OVER_TIME ||
		sp->EffectImplicitTargetB[0]==EFF_TARGET_ALL_TARGETABLE_AROUND_LOCATION_IN_RADIUS_OVER_TIME ||
		sp->EffectImplicitTargetB[1]==EFF_TARGET_ALL_TARGETABLE_AROUND_LOCATION_IN_RADIUS_OVER_TIME ||
		sp->EffectImplicitTargetB[2]==EFF_TARGET_ALL_TARGETABLE_AROUND_LOCATION_IN_RADIUS_OVER_TIME ||
		sp->EffectImplicitTargetA[0]==EFF_TARGET_ALL_TARGETABLE_AROUND_LOCATION_IN_RADIUS ||
		sp->EffectImplicitTargetA[1]==EFF_TARGET_ALL_TARGETABLE_AROUND_LOCATION_IN_RADIUS ||
		sp->EffectImplicitTargetA[2]==EFF_TARGET_ALL_TARGETABLE_AROUND_LOCATION_IN_RADIUS ||
		sp->EffectImplicitTargetB[0]==EFF_TARGET_ALL_TARGETABLE_AROUND_LOCATION_IN_RADIUS ||
		sp->EffectImplicitTargetB[1]==EFF_TARGET_ALL_TARGETABLE_AROUND_LOCATION_IN_RADIUS ||
		sp->EffectImplicitTargetB[2]==EFF_TARGET_ALL_TARGETABLE_AROUND_LOCATION_IN_RADIUS ||
		sp->EffectImplicitTargetA[0]==EFF_TARGET_ALL_ENEMIES_AROUND_CASTER ||
		sp->EffectImplicitTargetA[1]==EFF_TARGET_ALL_ENEMIES_AROUND_CASTER ||
		sp->EffectImplicitTargetA[2]==EFF_TARGET_ALL_ENEMIES_AROUND_CASTER ||
		sp->EffectImplicitTargetB[0]==EFF_TARGET_ALL_ENEMIES_AROUND_CASTER ||
		sp->EffectImplicitTargetB[1]==EFF_TARGET_ALL_ENEMIES_AROUND_CASTER ||
		sp->EffectImplicitTargetB[2]==EFF_TARGET_ALL_ENEMIES_AROUND_CASTER ||
		sp->EffectImplicitTargetA[0]==EFF_TARGET_ALL_ENEMY_IN_AREA_CHANNELED ||
		sp->EffectImplicitTargetA[1]==EFF_TARGET_ALL_ENEMY_IN_AREA_CHANNELED ||
		sp->EffectImplicitTargetA[2]==EFF_TARGET_ALL_ENEMY_IN_AREA_CHANNELED ||
		sp->EffectImplicitTargetB[0]==EFF_TARGET_ALL_ENEMY_IN_AREA_CHANNELED ||
		sp->EffectImplicitTargetB[1]==EFF_TARGET_ALL_ENEMY_IN_AREA_CHANNELED ||
		sp->EffectImplicitTargetB[2]==EFF_TARGET_ALL_ENEMY_IN_AREA_CHANNELED
		)
		return 1;

	if(	sp->NameHash == SPELL_HASH_MAGMA_TOTEM) 
		return 1;

	return 0;
}

// slow
struct SpellTargetMod
{
    SpellTargetMod(Object* _Target, uint8 _TargetModType) : Target(_Target), TargetModType(_TargetModType)
    {

    }
    Object* Target;
    uint8  TargetModType;
};

struct SpellTargetEntry
{
	SpellTargetEntry()
	{
		HasEffect[0] = false;
		HasEffect[1] = false;
		HasEffect[2] = false;
		EffectPoints[0] = 0;
		EffectPoints[1] = 0;
		EffectPoints[2] = 0;
		ProcData = 0;		
		TargetModType = 0;
		ExtendedTargetModType = 0;
	}
	bool HasEffect[3];
	uint32 EffectPoints[3];
	uint32 ProcData;
	uint8 TargetModType;
	uint8 ExtendedTargetModType; //used for reflected spells
};

typedef HM_NAMESPACE::hash_map<Object*, SpellTargetEntry> SpellTargetMap;
typedef std::vector<SpellTargetMod> SpellSpellTargetMap;

typedef void(Spell::*pSpellEffect)(uint32 i);
typedef void(Spell::*pSpellTarget)(uint32 i, uint32 j);

#define POWER_TYPE_HEALTH -2
#define POWER_TYPE_MANA 0
#define POWER_TYPE_RAGE 1
#define POWER_TYPE_FOCUS 2
#define POWER_TYPE_ENERGY 3
#define POWER_TYPE_HAPPINESS 4 //Randdrick
#define POWER_TYPE_RUNES 5
#define POWER_TYPE_RUNIC_POWER 6
#define NUM_POWER_TYPES 7
// we also have power type 15 and 31 :S
#define POWER_TYPE_BUFF_RESISTANCE 4 //Randdrick - Uniquement lié aux items pour les potions, elixirs par exemple

#define GO_FISHING_BOBBER 35591

#define SPELL_SPELL_CHANNEL_UPDATE_INTERVAL 1000
class DummySpellHandler;

//Note with SPELL_DID_HIT_REFLECT, another uint8 needs sent with the hit result on the reflected target
enum SpellDidHitResult
{
	SPELL_DID_HIT_SUCCESS					= 0,
	SPELL_DID_HIT_MISS						= 1,
	SPELL_DID_HIT_RESIST					= 2,
	SPELL_DID_HIT_DODGE						= 3,
	SPELL_DID_HIT_PARRY						= 4, //this is defect for projectiles, parry for non-projectiles, deflect isn't used anymore
	SPELL_DID_HIT_BLOCK						= 5,
	SPELL_DID_HIT_EVADE						= 6,
	SPELL_DID_HIT_IMMUNE					= 7,
	SPELL_DID_HIT_IMMUNE2					= 8,
	SPELL_DID_HIT_DEFLECT					= 9,
	SPELL_DID_HIT_ABSORB					= 10,
	SPELL_DID_HIT_REFLECT					= 11,
};

class SpellScript;
struct Modifier;
// Spell instance
class SERVER_DECL Spell : public EventableObject
{
public:
    friend class DummySpellHandler;
    Spell( Object* Caster, SpellEntry *info, bool triggered, Aura* aur);
    ~Spell();

    void Init();
	Object *m_closestDestObject[3];

	bool m_filledTargetMap;
	uint8 m_objectsHit;
	uint8 m_objectsModerated;

	uint32 npower;
	uint8 orunes;
	uint8 nrunes;

    uint8 delaycount;

	int32 m_instanceId;
	bool deleted;

	uint32 m_procdata; //could possible change for every target from an aoe, for example

	std::set<Aura*> m_auras;
	std::set<Unit*> m_auraTargets;

	uint32 GetBestSchoolForSpell(Unit* pVictim);
	void HandleDestLocationHit();

	//bool refill_map;
	uint32 triggered_id;
	Modifier* forced_modifier;
	uint32 forced_applications; //for auras, 0=none

	bool hasended;
	bool summonveh;
	void EventDelete();

	int32 event_GetInstanceID();

    // Fills specified targets at the area of effect
    void FillSpecifiedTargetsInArea(float srcx,float srcy,float srcz,uint32 ind, uint32 specification);
    // Fills specified targets at the area of effect. We suppose we already inited this spell and know the details
    void FillSpecifiedTargetsInArea(uint32 i,float srcx,float srcy,float srcz, float range, uint32 specification);
    // Fills the targets at the area of effect
    void FillAllTargetsInArea(uint32 i, float srcx,float srcy,float srcz, float range);
    // Fills the targets at the area of effect. We suppose we already inited this spell and know the details
    void FillAllTargetsInArea(float srcx,float srcy,float srcz,uint32 ind);
    // Fills the targets at the area of effect. We suppose we already inited this spell and know the details
    void FillAllTargetsInArea(LocationVector & location,uint32 ind);
    // Fills the targets at the area of effect. We suppose we already inited this spell and know the details
    void FillAllFriendlyInArea(uint32 i, float srcx,float srcy,float srcz, float range);
    //get single Enemy as target
    uint64 GetSinglePossibleEnemy(uint32 i, float prange=0);
    //get single Friend as target
    uint64 GetSinglePossibleFriend(uint32 i, float prange=0);
    //generate possible target list for a spell. Use as last resort since it is not acurate
    void GenerateTargets(SpellCastTargets *store_buff);
    // Fills the target map of the spell packet
    void FillTargetMap(uint32);
    // See if we hit the target or can it resist (evade/immune/resist on spellgo) (0=success)
    uint8 DidHit(uint32 effindex,Unit* target);
    // Prepares the spell thats going to cast to targets
    uint8 prepare(SpellCastTargets * targets);
    // Cancels the current spell
    void cancel(uint8 result);
    // Update spell state based on time difference
    void update(uint32 difftime);
    // Casts the spell
    void cast(bool);
    // Finishes the casted spell
    void finish();
    // Handles the times de
    void HandleCastEffects(Object* obj, uint32 i, bool reflected = false);
    // Handle the Effects of the Spell
    void HandleEffects(Object* obj, uint32 i, bool reflected);
    // New Handle the Effects of the Spell
    // void NewHandleEffects(uint32 i);
    // Take Power from the caster based on spell power usage
    bool TakePower();
    // Has power?
    bool HasPower();
    // Trigger Spell function that triggers triggered spells
    void TriggerSpell();
    // Checks the caster is ready for cast
    uint8 CanCast(bool);
	uint8 CanCastSpell(void); // Nouvelle fonction (Recodage des spells)
    // Removes reagents, ammo, and items/charges
    void RemoveItems(Item *Item_To_Remove);
    // Calculates the i'th effect value
    int32 CalculateEffect(uint32, Unit *target);
    // Handles Teleport function
    void HandleTeleport(uint32 id, Unit* Target);
    // Determines how much skill caster going to gain
    void DetermineSkillUp();
    // Increases cast time of the spell
    void AddTime(uint32 type);
    void AddCooldown();
    void AddStartCooldown();


    bool Reflect(Unit * refunit);

    ASCENT_INLINE uint32 getState() { return m_spellState; }
    ASCENT_INLINE void SetUnitTarget(Unit *punit){unitTarget=punit;}
	ASCENT_INLINE SpellEntry *GetSpellProto() { return m_spellInfo; }

    // Send Packet functions
    void SendCastResult(uint8 result);
    void SendSpellStart();
	void FillUniqueTargets();
    void SendSpellGo();
    void SendLogExecute(uint32 damage, uint64 & targetGuid);
    void SendInterrupted(uint8 result);
    void SendChannelUpdate(uint32 time);
    void SendChannelStart(uint32 duration);
    void SendResurrectRequest(Player* target);
	static void SendHealSpellOnPlayer(Object *caster, Object *target, uint32 dmg, bool critical, uint32 overheal, uint32 spellid);
    static void SendHealManaSpellOnPlayer(Object *caster, Object *target, uint32 dmg, uint32 powertype, uint32 spellid);
    /*void SendHealSpellOnPlayer(Object* caster, Object* target, uint32 dmg,bool critical);
    void SendHealManaSpellOnPlayer(Object * caster, Object * target, uint32 dmg, uint32 powertype);*/
    
    void HandleAddAura(Unit* u, Aura* a);
	void NewHandleAddAura(uint64 guid);
    void writeSpellGoTargets( WorldPacket * data );
    void writeSpellMissedTargets( WorldPacket * data );

    SpellEntry* m_spellInfo;
    uint32 pSpellId;
    SpellEntry *ProcedOnSpell; //some spells need to know the origins of the proc too
    SpellCastTargets m_targets;

    void CreateItem(uint32 itemId);

	// Misc 3.3.2 (Branruz)
	void LoadSpellEffect(void);

    // Effect Handlers
    void SpellEffectNULL(uint32 i);
    void SpellEffectInstantKill(uint32 i);
    void SpellEffectSchoolDMG(uint32 i);
    void SpellEffectDummy(uint32 i);
    void SpellEffectTeleportUnits(uint32 i);
    void SpellEffectApplyAura(uint32 i);
    void SpellEffectPowerDrain(uint32 i);
    void SpellEffectHealthLeech(uint32 i);
    void SpellEffectHeal(uint32 i);
	void SpellEffectBind(uint32 i);
    void SpellEffectQuestComplete(uint32 i);
    void SpellEffectWeapondamageNoschool(uint32 i);
    void SpellEffectResurrect(uint32 i);
    void SpellEffectAddExtraAttacks(uint32 i);
    void SpellEffectDodge(uint32 i);
    void SpellEffectBlock(uint32 i);
    void SpellEffectParry(uint32 i);
    void SpellEffectCreateItem(uint32 i);
    void SpellEffectPersistentAA(uint32 i);
    void SpellEffectSummon(uint32 i);
    void SpellEffectLeap(uint32 i);
    void SpellEffectEnergize(uint32 i);
    void SpellEffectWeaponDmgPerc(uint32 i);
    void SpellEffectTriggerMissile(uint32 i);
    void SpellEffectOpenLock(uint32 i);
    void SpellEffectApplyAA(uint32 i);
    void SpellEffectLearnSpell(uint32 i);
    void SpellEffectSpellDefense(uint32 i);
    void SpellEffectDispel(uint32 i);
	void SpellEffectLanguage(uint32 i);
    void SpellEffectSkillStep(uint32 i);
	void SpellEffectDetect(uint32 i);
    void SpellEffectSummonObject(uint32 i);
    void SpellEffectEnchantItem(uint32 i);
    void SpellEffectEnchantItemTemporary(uint32 i);
    void SpellEffectTameCreature(uint32 i);
    void SpellEffectSummonPet(uint32 i);
    void SpellEffectWeapondamage(uint32 i);
    void SpellEffectPowerBurn(uint32 i);
    void SpellEffectThreat(uint32 i);
    void SpellEffectTriggerSpell(uint32 i);
    void SpellEffectApplyRaidAA(uint32 i);
    void SpellEffectPowerFunnel(uint32 i);
    void SpellEffectHealMaxHealth(uint32 i);
    void SpellEffectInterruptCast(uint32 i);
    void SpellEffectDistract(uint32 i);
	void SpellEffectPull(uint32 i);
    void SpellEffectPickpocket(uint32 i);
    void SpellEffectAddFarsight(uint32 i);
    void SpellEffectHealMechanical(uint32 i);
    void SpellEffectSummonObjectWild(uint32 i);
    void SpellEffectScriptEffect(uint32 i);
    void SpellEffectSanctuary(uint32 i);
    void SpellEffectAddComboPoints(uint32 i);
	void SpellEffectCreateHouse(uint32 i);
    void SpellEffectDuel(uint32 i);
    void SpellEffectStuck(uint32 i);
    void SpellEffectSummonPlayer(uint32 i);
    void SpellEffectActivateObject(uint32 i);
    void SpellEffectProficiency(uint32 i);
    void SpellEffectSendEvent(uint32 i);
    void SpellEffectSkinning(uint32 i);
    void SpellEffectCharge(uint32 i);
    void SpellEffectKnockBack(uint32 i);
    void SpellEffectInebriate(uint32 i);
    void SpellEffectFeedPet(uint32 i);
    void SpellEffectDismissPet(uint32 i);
    void SpellEffectReputation(uint32 i);
    void SpellEffectSummonObjectSlot(uint32 i);
    void SpellEffectDispelMechanic(uint32 i);
    void SpellEffectSummonDeadPet(uint32 i);
    void SpellEffectDestroyAllTotems(uint32 i);
    void SpellEffectSummonDemon(uint32 i);
    void SpellEffectAttackMe(uint32 i);
    void SpellEffectSkill(uint32 i);
    void SpellEffectApplyPetAura(uint32 i);
    void SpellEffectDummyMelee(uint32 i);
	void SpellEffectSendTaxi(uint32 i);
    void SpellEffectPlayerPull( uint32 i );
    void SpellEffectSpellSteal(uint32 i);
    void SpellEffectProspecting(uint32 i);
    void SpellEffectOpenLockItem(uint32 i);
    void SpellEffectSelfResurrect(uint32 i);
    void SpellEffectDisenchant(uint32 i);
    void SpellEffectWeapon(uint32 i);
    void SpellEffectDefense(uint32 i);
    void SpellEffectDualWield(uint32 i);
    void SpellEffectSkinPlayerCorpse(uint32 i);
    void SpellEffectResurrectNew(uint32 i);
    void SpellEffectTranformItem(uint32);
    void SpellEffectEnvironmentalDamage(uint32);
    void SpellEffectLearnPetSpell(uint32 i);
    void SpellEffectEnchantHeldItem(uint32 i);
    void SpellEffectAddHonor(uint32 i);
    void SpellEffectSpawn(uint32 i);
    void SpellEffectApplyAura128(uint32 i);
	void SpellEffectRedirectThreat(uint32 i);
	void SpellEffectTriggerSpellWithValue(uint32 i);
	void SpellEffectPlayMusic(uint32 i);
	void SpellEffectForgetSpecialization(uint32 i);
	void SpellEffectClearFinishedQuest(uint32 i);
	void SpellEffectJumpMove(uint32 i);
	// Glyph
	void SpellEffectApplyGlyph(uint32 i);
	// HearthStone
	void SpellEffectCreateRandomItem(uint32 i);
	void SpellEffectKillCredit(uint32 i);
	void SpellEffectMilling(uint32 i);
	void SpellEffectLearnSpec(uint32 i);
	void SpellEffectActivateSpec(uint32 i);
	void SpellEffectRestoreHealthPct(uint32 i);
	void SpellEffectRestoreManaPct(uint32 i);
	void SpellEffectDisengage(uint32);
	void SpellEffectTitanGrip(uint32 i);
	void SpellEffectApplyDemonAura( uint32 i );
	void SpellEffectActivateRune(uint32 i);
	void SpellEffectFailQuest(uint32 i);
	void SpellEffectStartQuest(uint32 i);
	void SpellEffectCreatePet(uint32 i);
	void SpellEffectAddPrismaticSocket(uint32 i);
	void SpellEffectAllowPetRename( uint32 i );
	void SpellEffectActivateTalentSpec(uint32 i);
	void SpellEffectRemoveAura(uint32 i);
	// GoDestructible
	void SpellEffectWMODamage(uint32 i);
	void SpellEffectWMORepair(uint32 i);
	void SpellEffectChangeWMOState(uint32 i);
	// MegaBigBoss
	void SpellEffectTeleportUnitsFaceCaster(uint32 i);

    uint64 static FindLowestHealthRaidMember(Player *Target, uint32 dist);

	//new target handles
	uint32 GetTargetType(uint32 value, uint32 i);
	bool AddTarget(uint32 i, uint32 TargetType, Object* obj);
	void AddAOETargets(uint32 i, uint32 TargetType, float r, uint32 maxtargets);
	void AddPartyTargets(uint32 i, uint32 TargetType, float r, uint32 maxtargets);
	void AddRaidTargets(uint32 i, uint32 TargetType, float r, uint32 maxtargets, bool partylimit = false);
	void AddChainTargets(uint32 i, uint32 TargetType, float r, uint32 maxtargets);
	void AddConeTargets(uint32 i, uint32 TargetType, float r, uint32 maxtargets);
	void AddScriptedOrSpellFocusTargets(uint32 i, uint32 TargetType, float r, uint32 maxtargets);

    void Heal(int32 amount, bool ForceCrit = false);
	//void Heal(int32 amount);

   // GameObject*		g_caster; // Raccourci
   // Unit*			u_caster; // Raccourci
   // Item*			i_caster; // Raccourci
   // Player*			p_caster; // Raccourci
    Object*			m_caster; // Source peut etre un GameObject,Item,Player ou PNJ
	Object*			m_owner; // Declencheur du spell peut etre un GameObject,Item,Player ou PNJ

    // 15007 = resurecting sickness
	
	// This returns SPELL_ENTRY_defenseType where 0 = defenseType_NONE, 1 = DEFENSE_TYPE_MAGIC, 2 = defenseType_MELEE, 3 = DEFENSE_TYPE_RANGED
	// It should NOT be used for weapon_damage_type which needs: 0 = MELEE, 1 = OFFHAND, 2 = RANGED
	// Il faut faire la diff avec un type Player (Branruz)
	uint32 GetType() 
	{ 
		if(m_caster->IsPlayer()) return ( m_spellInfo->defenseType == DEFENSE_TYPE_NONE ? DEFENSE_TYPE_MAGIC : m_spellInfo->defenseType ); 
		else                     return ( m_spellInfo->defenseType ); 
	}
	ASCENT_INLINE Item* GetItemTarget() 
	{ 
		if (itemTarget == NULL && m_targets.m_target != NULL && m_targets.m_target->GetTypeId() == TYPEID_ITEM) 
			return static_cast<Item*>(m_targets.m_target); 
		else return itemTarget; 
	}
	ASCENT_INLINE Unit* GetUnitTarget() 
	{ 
		if (unitTarget == NULL && m_targets.m_target != NULL && m_targets.m_target->IsUnit()) 
			return static_cast<Unit*>(m_targets.m_target); 
		else return unitTarget; 
	}
    ASCENT_INLINE Player* GetPlayerTarget() { return playerTarget; }
    ASCENT_INLINE GameObject* GetGameObjectTarget() { return gameObjTarget; }
    void SetSpellTargets(const uint64& guid);
    uint32 chaindamage;
    // -------------------------------------------

    bool IsAspect();
    bool IsSeal();
	bool static IsBinary(SpellEntry * sp);

    int32 GetDuration(uint32 _type)
    {
        if(bDurSet)  
		{
		//sLog.outDetail("GetDuration: Spell: %u, dur Type: %u, duree: %d",m_spellInfo->Id,_type,this->Dur);
		 return (this->Dur);
	    }
        bDurSet=true;

        int32 c_dur = 0;

        if(m_spellInfo->durationIndex)
        {
            SpellDuration *sd=dbcSpellDuration.LookupEntry(m_spellInfo->durationIndex);

            if(sd)
            {
				//sLog.outDetail("GetDuration: Spell: %u, Type: %u, Index: %u, Dur1: %d, Dur2: %d, Dur3: %d",
			    //                       m_spellInfo->Id,_type,m_spellInfo->durationIndex,
				//					   sd->Duration1,sd->Duration2,sd->Duration3);
                //check for negative and 0 durations.
                //duration affected by level
                if((sd->Duration1 == -1) && (sd->Duration2==0)) // Modif Branruz, prise en compte de -1 a la lecture
				{
                  this->Dur = -1;
				  //return(this->Dur);
				}
				else if((sd->Duration1 < 0) && (sd->Duration2!=0) && m_caster->IsUnit()) // u_caster)
                {
                    this->Dur = int32((sd->Duration1 + (sd->Duration2 * ((Unit *)m_caster)->getLevel())));
                    if((this->Dur > 0 && sd->Duration3 > 0) && (this->Dur > (int32)sd->Duration3) )
                    {
                        this->Dur = sd->Duration3;
                    }

                    if(this->Dur < 0) this->Dur = 0;

					c_dur = this->Dur;
                }

                if(sd->Duration1 >= 0 && !c_dur)
                {
                    this->Dur = sd->Duration1;
                }
                //combo point lolerCopter? ;P

				if(m_caster->IsPlayer())  
                {
                    uint32 cp = ((Player *)m_caster)->m_comboPoints;
                    if(cp)
                    {
                        uint32 bonus=(cp*(sd->Duration3 - sd->Duration1))/5;
                        if(bonus)
                        {
                            this->Dur+=bonus;
                            m_requiresCP=true;
                        }
                    }
                }

				if(this->Dur >= 0)
				{
					if((m_spellInfo->SpellGroupType[0] || m_spellInfo->SpellGroupType[1] || m_spellInfo->SpellGroupType[2]) && m_caster->IsUnit())
                 {
                    SM_FIValue(((Unit *)m_caster)->SM_FDur,(int32*)&this->Dur,m_spellInfo);
                    SM_PIValue(((Unit *)m_caster)->SM_PDur,(int32*)&this->Dur,m_spellInfo);
                 }
				}
            }
            else
            {
                this->Dur = -1;
            }
        }
        else
        {
             this->Dur = -1;
        }

		//sLog.outDetail("GetDuration End: (%s) Spell: %u, Type: %u, Index: %u, Dur: %d",m_spellInfo->Name,
		//	                           m_spellInfo->Id,_type,m_spellInfo->durationIndex,this->Dur);
		//if(u_caster) sLog.outDetail("GetDuration End: u_caster: %u ",u_caster->GetEntry());
		
		
        return (this->Dur);
    }

	ASCENT_INLINE float GetRadius(uint32 i)
    {
        if(bRadSet[i])return Rad[i];
        bRadSet[i]=true;
        Rad[i]=::GetRadius(dbcSpellRadius.LookupEntry(m_spellInfo->EffectRadiusIndex[i]));
		if(m_caster->IsUnit())
		{
         if(m_spellInfo->SpellGroupType[0] || m_spellInfo->SpellGroupType[1] || m_spellInfo->SpellGroupType[2])
         {
            SM_FFValue(((Unit *)m_caster)->SM_FRadius,&Rad[i],m_spellInfo);
            SM_PFValue(((Unit *)m_caster)->SM_PRadius,&Rad[i],m_spellInfo);
         }
		}

        return Rad[i];
    }

    ASCENT_INLINE static uint32 GetBaseThreat(uint32 dmg)
    {
        //there should be a formula to determine what spell cause threat and which don't
/*        switch(m_spellInfo->NameHash)
        {
            //hunter's mark
            case SPELL_HASH_HUNTER_S_MARK:
                {
                    return 0;
                }break;
        }*/
        return dmg;
    }
	
		ASCENT_INLINE static bool HasMechanic(SpellEntry * sp, uint32 mechanics)
	{
		return sp->mechanics == mechanics ||
			(uint32)sp->EffectMechanic[0] == mechanics ||
			(uint32)sp->EffectMechanic[1] == mechanics ||
			(uint32)sp->EffectMechanic[2] == mechanics;
	}

	ASCENT_INLINE static uint32 GetMechanic(SpellEntry * sp)
	{
		if(sp->mechanics) 
			return sp->mechanics;
		if(sp->EffectMechanic[2])
			return sp->EffectMechanic[2];
		if(sp->EffectMechanic[1])
			return sp->EffectMechanic[1];
		if(sp->EffectMechanic[0])
			return sp->EffectMechanic[0];

		return 0;
	}

	ASCENT_INLINE static uint32 GetMechanicOfEffect(SpellEntry * sp, uint32 i)
	{
		if(sp->EffectMechanic[i])
			return sp->EffectMechanic[i];
		if(sp->mechanics)
			return sp->mechanics;

		return 0;
	}

    bool IsStealthSpell();
    bool IsInvisibilitySpell();
    
	float amp;
    int32 damage;
    Aura* m_triggeredByAura;
	signed int	forced_basepoints[3]; //some talent inherit base points from previous caster spells

    bool m_triggeredSpell;
    bool m_AreaAura;
    //uint32 TriggerSpellId;  // used to set next spell to use
    //uint64 TriggerSpellTarget; // used to set next spell target
    bool m_requiresCP;
    float m_castPositionX;
    float m_castPositionY;
    float m_castPositionZ;
   
    int32 damageToHit;
    uint32 castedItemId;
    bool judgement;
	uint8 extra_cast_number;
	uint32 m_glyphIndex;

    void SendCastSuccess(Object * target);
    void SendCastSuccess(const uint64& guid);

    bool duelSpell;

	ASCENT_INLINE void safe_cancel()
	{
		m_cancelled = true;
	}

    /// Spell state's
    /// Spell failed
    ASCENT_INLINE bool GetSpellFailed(){return m_Spell_Failed;}
    ASCENT_INLINE void SetSpellFailed(bool failed = true){m_Spell_Failed = failed;}
    
	Spell * m_reflectedParent;

	SpellScript* m_spellScript;

	ASCENT_INLINE static bool IsJudgement(SpellEntry* sp)
	{
		if (sp == NULL) return false;

		switch (sp->NameHash)
		{
		case SPELL_HASH_JUDGEMENT:
		case SPELL_HASH_JUDGEMENT_ANTI_PARRY_DODGE_PASSIVE:
		case SPELL_HASH_JUDGEMENT_BLOCK_VALUE:
		case SPELL_HASH_JUDGEMENT_COOLDOWN_REDUCTION:
		case SPELL_HASH_JUDGEMENT_GROUP_HEAL:
		case SPELL_HASH_JUDGEMENT_OF_BLOOD:
		case SPELL_HASH_JUDGEMENT_OF_COMMAND:
		case SPELL_HASH_JUDGEMENT_OF_CORRUPTION:
		case SPELL_HASH_JUDGEMENT_OF_DARKNESS:
		case SPELL_HASH_JUDGEMENT_OF_JUSTICE:
		case SPELL_HASH_JUDGEMENT_OF_LIGHT:
		case SPELL_HASH_JUDGEMENT_OF_ONSLAUGHT:
		case SPELL_HASH_JUDGEMENT_OF_RECKONING:
		case SPELL_HASH_JUDGEMENT_OF_RIGHTEOUSNESS:
		case SPELL_HASH_JUDGEMENT_OF_THE_FLAME:
		case SPELL_HASH_JUDGEMENT_OF_THE_MARTYR:
		case SPELL_HASH_JUDGEMENT_OF_THE_VAL_KYR:
		case SPELL_HASH_JUDGEMENT_OF_THE_VAL_KYR_OVERSEER:
		case SPELL_HASH_JUDGEMENT_OF_VENGEANCE:
		case SPELL_HASH_JUDGEMENT_OF_WISDOM:
		case SPELL_HASH_JUDGEMENT_OF_WRATH:
		case SPELL_HASH_JUDGEMENT_PRIMER:
		case SPELL_HASH_JUDGEMENT_SMITE:
		case SPELL_HASH_JUDGEMENTS_OF_THE_JUST:
		case SPELL_HASH_JUDGEMENTS_OF_THE_PURE:
		case SPELL_HASH_JUDGEMENTS_OF_THE_WISE:
		case SPELL_HASH_JUDGMENT_COOLDOWN_REDUCTION:
			return true;
		default:
			return false;
		}
	}

	SpellTargetMap m_spellTargets;

protected:

    /// Spell state's
    bool    m_usesMana;
    bool    m_Spell_Failed;        //for 5sr
    bool    m_IsReflected;
    bool    m_Delayed;
    
       
    bool m_IsCastedOnSelf;

    bool hadEffect;

    uint32  m_spellState;
    int32   m_castTime;
    int32   m_timer;
	bool    m_ForceConsumption;
    
    

    // Current Targets to be used in effect handler
    Unit*       unitTarget;
    Item*       itemTarget;
    GameObject* gameObjTarget;
    Player*     playerTarget;
    Corpse*     corpseTarget;
    uint32      add_damage;

	Object*		m_backupTarget;

    uint8       cancastresult;
    int32       Dur;
    bool        bDurSet;
    float       Rad[3];
    bool        bRadSet[3];
	bool        m_cancelled;
	bool m_isCasting;
	bool m_projectileWait;

    //void _DamageRangeUpdate();

	ASCENT_INLINE bool HasTarget(Object* obj, SpellTargetMap* tmpMap)
	{
		if (tmpMap->count(obj) > 0)
			return true;

		return false;
	}

private:
	struct SpellTarget
	{
		uint64 Guid;
		uint8 HitResult;
		uint8 EffectMask;
	};

	typedef vector<SpellTarget> SpellTargetList;
	SpellTargetList m_targetList;
	
	// adds a target to the list, performing DidHit checks
	void _AddTarget(const Unit *target, const uint32 effectid);

	// adds a target to the list, negating DidHit checks
	void _AddTargetForced(const uint64& guid, const uint32 effectid);
	
	// sets the pointers (unitTarget, itemTarget, etc) for a given guid
	void _SetTargets(const uint64& guid);
	
	std::vector<Object*> m_orderedObjects;
    friend class DynamicObject;
    void DetermineSkillUp(uint32 skillid,uint32 targetlevel);
    void DetermineSkillUp(uint32 skillid);

	
	/*uint32 m_hitTargetCount;
	uint32 m_missTargetCount;*/

	/* magnet
	Unit *m_magnetTarget;*/
};

void ApplyDiminishingReturnTimer(int32 * Duration, Unit * Target, SpellEntry * spell);
void UnapplyDiminishingReturnTimer(Unit * Target, SpellEntry * spell);
uint32 GetDiminishingGroup(uint32 NameHash);
char *SpellCastErrorMsg(uint8 error_result);
char *SpellEffectTxt(uint8 EffectNum);
uint32 GetSpellClass(SpellEntry *sp);

#endif
