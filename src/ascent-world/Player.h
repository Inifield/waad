/*
 * Ascent MMORPG Server
 * Copyright (C) 2005-2008 Ascent Team <http://www.ascentcommunity.com/>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef _PLAYER_H
#define _PLAYER_H
struct BGScore;
class Channel;
class Creature;
class Battleground;
class TaxiPath;
class GameObject;
class Transporter;
class Corpse;
class Guild;
struct GuildRank;
class Pet;
class Charter;
class LFGMatch;
struct LevelInfo;
#define MAX_PET_NO 3
#define PLAYER_NORMAL_RUN_SPEED 7.0f
#define PLAYER_NORMAL_SWIM_SPEED 4.722222f
#define PLAYER_NORMAL_FLIGHT_SPEED 7.0f
#define PLAYER_HONORLESS_TARGET_SPELL 2479
#define MONSTER_NORMAL_RUN_SPEED 8.0f
/* action button defines */
#define PLAYER_ACTION_BUTTON_COUNT 136
#define PLAYER_ACTION_BUTTON_SIZE PLAYER_ACTION_BUTTON_COUNT * sizeof(ActionButton)
#define MAX_SPEC_COUNT 2
#define GLYPHS_COUNT 6

#define FACTION_NEUTRAL -1
#define FACTION_ALLY	0
#define FACTION_HORDE	1

/*
Arbre de Talents:
	161/163/164 	// Wawa      (Combat/Def/Fury)
	382/383/381 	// Paladin
	361/363/362 	// Chasseur
	182/181/183 	// Voleur
	201/202/203 	// Pretre
	398/399/400 	// Chevalier de la mort
	261/263/262 	// Shaman
	 81/ 41/ 61 	// Mage
	302/303/301 	// Demoniste
	283/281/282 	// Druide
*/
//====================================================================
//  Inventory
//  Holds the display id and item type id for objects in
//  a character's inventory
//====================================================================

struct RuneSlot
{
	uint8 index;
	uint8 originalType;
	uint8 runeType;
	uint32 activateTime;
};

enum Classes
{
	UNK_CLASS1  = 0,
	WARRIOR     = 1,
	PALADIN     = 2,
	HUNTER      = 3,
	ROGUE       = 4,
	PRIEST      = 5,
	DEATHKNIGHT = 6,
	SHAMAN      = 7,
	MAGE        = 8,
	WARLOCK     = 9,
	UNK_CLASS2  = 10,
	DRUID       = 11,
};

enum Races
{
	RACE_HUMAN    = 1,
	RACE_ORC      = 2,
	RACE_DWARF    = 3,
	RACE_NIGHTELF = 4,
	RACE_UNDEAD   = 5,
	RACE_TAUREN   = 6,
	RACE_GNOME    = 7,
	RACE_TROLL    = 8,
	RACE_GOBLIN   = 9,
	RACE_BLOODELF = 10,
	RACE_DRAENEI  = 11,

	MAX_RACE_NORMAL = 12,

	RACE_FELORC        = 12, // Gangr'orc
	RACE_NAGA          = 13,
	RACE_BROKEN        = 14, // Roué
	RACE_SKELETON      = 15,
	RACE_VRYKUL        = 16,
	RACE_TUSKAR        = 17, // Rohart
	RACE_FORTESTROLL   = 18, // Troll des forets
	RACE_TAUNKA        = 19,  
	RACE_LK_SQUELETON  = 20, // Squelette du Northrend
	RACE_ICE_TROLL     = 21,  // Troll des glaces
	MAX_RACE_EXTENDED
};

enum PlayerStatus
{
	NONE			 = 0,
	TRANSFER_PENDING = 1,
};
// A Verifier (Branruz) 
// TitleFlag = Bitmap sur un uint64, donc 64 valeur max
// Source Mangos - > 3 uint64 possibles donc 192 valeur Max 
// CharTitleDbc 3.3.2 : 142 Titres 
enum RankTitles 
{
	TITLE_NONE                    	= 0,
	TITLE_PRIVATE                 	= 1,
	TITLE_CORPORAL                	= 2,
	TITLE_SERGEANT                	= 3,
	TITLE_MASTER_SERGEANT         	= 4,
	TITLE_SERGEANT_MAJOR          	= 5,
	TITLE_KNIGHT                  	= 6,
	TITLE_KNIGHT_LIEUTENANT       	= 7,
	TITLE_KNIGHT_CAPTAIN          	= 8,
	TITLE_KNIGHT_CHAMPION         	= 9,
	TITLE_LIEUTENANT_COMMANDER    	= 10,
	TITLE_COMMANDER               	= 11,
	TITLE_MARSHAL                 	= 12,
	TITLE_FIELD_MARSHAL           	= 13,
	TITLE_GRAND_MARSHAL           	= 14,
	TITLE_SCOUT                   	= 15,
	TITLE_GRUNT                   	= 16,
	TITLE_HSERGEANT                	= 17,
	TITLE_SENIOR_SERGEANT         	= 18,
	TITLE_FIRST_SERGEANT          	= 19,
	TITLE_STONE_GUARD             	= 20,
	TITLE_BLOOD_GUARD             	= 21,
	TITLE_LEGIONNAIRE             	= 22,
	TITLE_CENTURION               	= 23,
	TITLE_CHAMPION                	= 24,
	TITLE_LIEUTENANT_GENERAL      	= 25,
	TITLE_GENERAL                 	= 26,
	TITLE_WARLORD                 	= 27,
	TITLE_HIGH_WARLORD            	= 28,
	TITLE_GLADIATOR	              	= 29,
	TITLE_DUELIST	              	= 30,
	TITLE_RIVAL		              	= 31,
	TITLE_CHALLENGER              	= 32,
	TITLE_SCARAB_LORD             	= 33,
	TITLE_CONQUEROR               	= 34,
	TITLE_JUSTICAR                	= 35,
	TITLE_CHAMPION_OF_THE_NAARU   	= 36,
	TITLE_MERCILESS_GLADIATOR     	= 37,
	TITLE_SHATTERED_SUN		      	= 38,
	TITLE_HAND_OF_ADAL			  	= 39,
	TITLE_VENGEFUL_GLADIATOR	  	= 40,
	TITLE_BATTLEMASTER				= 41,
	TITLE_ELDER						= 42,
	TITLE_FLAME_WARDEN				= 43,
	TITLE_FLAME_KEEPER				= 44,
	TITLE_THE_EXALTED				= 45,
	TITLE_THE_EXPLORER				= 46,
	TITLE_THE_DIPLOMAT				= 47,
	TITLE_BRUTAL_GLADIATOR			= 48,
	TITLE_SEEKER					= 49,
	TITLE_ARENA_MASTER				= 50,
	TITLE_SALTY						= 51,
	TITLE_CHEF						= 52,
	TITLE_THE_SUPREME				= 53,
	TITLE_OF_THE_TEN_STORMS			= 54,
	TITLE_OF_THE_EMERALD_DREAM		= 55,
	TITLE_PROPHET					= 56,
	TITLE_THE_MALEFIC				= 57,
	TITLE_STALKER					= 58,
	TITLE_OF_THE_EBON_BLADE			= 59,
	TITLE_ARCHMAGE					= 60,
	TITLE_WARBRINGER				= 61,
	TITLE_ASSASSIN					= 62,
	TITLE_GRND_MSTR_ALCHEMIST		= 63,
	TITLE_GRND_MSTR_BLACKSMITH		= 64,
	TITLE_IRON_CHEF					= 65,
	TITLE_GRND_MSTR_ENCHANTER		= 66,
	TITLE_GRND_MSTR_ENGINEER		= 67,
	TITLE_DOCTOR					= 68,
	TITLE_GRND_MSTR_ANGLER			= 79,
	TITLE_GRND_MSTR_HERBALIST		= 70,
	TITLE_GRND_MSTR_SCRIBE			= 71,
	TITLE_GRND_MSTR_JEWELCRAFT		= 72,
	TITLE_GRND_MSTR_LEATHERWORK		= 73,
	TITLE_GRND_MSTR_MINER			= 74,
	TITLE_GRND_MSTR_SKINNER			= 75,
	TITLE_GRND_MSTR_TAILOR			= 76,
	TITLE_OF_QUEL_THALAS			= 77,
	TITLE_OF_ARGUS					= 78,
	TITLE_OF_KHAZ_MODAN				= 79,
	TITLE_GNOMEREGAN				= 80,
	TITLE_LION_HEARTED				= 81,
	TITLE_CHAMPION_OF_ELUNE			= 82,
	TITLE_HERO_OF_ORGRIMMAR			= 83,
	TITLE_PLAINSRUNNER				= 84,
	TITLE_OF_THE_DARKSPEAR			= 85,
	TITLE_THE_FORSAKEN				= 86,
	TITLE_THE_MAGIC_SEEKER			= 87,
	TITLE_TWILIGHT_VANQUISHER		= 88,
	TITLE_CONQUEROR_OF_NAXXRAMA		= 89,
	TITLE_HERO_OF_NORTHREND			= 90,
	TITLE_THE_HALLOWED				= 91,
	TITLE_LOREMASTER				= 92,
	TITLE_OF_THE_ALLIANCE			= 93,
	TITLE_OF_THE_HORDE				= 94,
	TITLE_THE_FLAWLESS_VICTOR		= 95,
	TITLE_CHAMP_OF_FROZEN_WASTE		= 96,
	TITLE_AMBASSADOR				= 97,
	TITLE_THE_ARGENT_CHAMPION		= 98,
	TITLE_GUARDIAN_OF_CENARIUS		= 99,
	TITLE_BREWMASTER				= 100,
	TITLE_MERRYMAKER				= 101,
	TITLE_THE_LOVE_FOOL				= 102,
	TITLE_MATRON					= 103,
	TITLE_PATRON					= 104,
	TITLE_OBSIDIAN_SLAYER			= 105,
	TITLE_OF_THE_NIGHTFALL			= 106,
	TITLE_THE_IMMORTAL				= 107,
	TITLE_THE_UNDYING				= 108,
	TITLE_JENKINS					= 109,
	TITLE_BLOODSAIL_ADMIRAL			= 110,
	TITLE_THE_INSANE				= 111,
	TITLE_OF_THE_EXODAR				= 112,
	TITLE_OF_DARNASSUS				= 113,
	TITLE_OF_INRONFORGE				= 114,
	TITLE_OF_STORMWIND				= 115,
	TITLE_OF_ORGRIMMAR				= 116,
	TITLE_OF_SENJIN					= 117,
	TITLE_OF_SILVERMOON				= 118,
	TITLE_OF_THUNDERBLUFF			= 119,
	TITLE_OF_THE_UNDERCITY			= 120,
	TITLE_THE_NOBLE					= 121,
	TITLE_CRUSADER					= 122,
	TITLE_DEADLY_GLADIATOR			= 123,
	TITLE_DEATH_DEMISE				= 124,
	TITLE_THE_CELESTIAL_DEFENDER	= 125,
	TITLE_CONQUEROR_OF_ULDAR		= 126,
	TITLE_CHAMPION_OF_ULDAR			= 127,
	TITLE_VANQUISHER				= 128,
	TITLE_STARCALLER				= 129,
	TITLE_THE_ASTRAL_WALKER			= 130,
	TITLE_HERALD_OF_THE_TITANS		= 131,
	TITLE_FURIOUS_GLADIATOR			= 132,
	TITLE_THE_PILGRIM				= 133,
	TITLE_RELENTESS_GLADIATOR		= 134,
	TITLE_GRND_CRUSADER				= 135,
	TITLE_THE_ARGENT_DEFENDER		= 136,
	TITLE_THE_PATIENT				= 137,
	TITLE_THE_LIGHT_OF_DAWN			= 138,
	TITLE_BANE_OF_THE_FALLEN_KING	= 139,
	TITLE_THE_KINGSLAYER			= 140,
	TITLE_OF_THE_ASHEN_VERDICT		= 141,
	TITLE_WRATHFUL_GLADIATOR		= 142,
	TITLE_END						= 143,
};

#define KNOWN_TITLES_SIZE   3
#define MAX_TITLE_INDEX     (KNOWN_TITLES_SIZE*64)          // 3 uint64 fields

enum PvPAreaStatus
{
    AREA_ALLIANCE  = 1,
    AREA_HORDE     = 2,
    AREA_CONTESTED = 3,
    AREA_PVPARENA  = 4,
};

enum PlayerMovementType
{
    MOVE_ROOT	    = 1,
    MOVE_UNROOT	    = 2,
    MOVE_WATER_WALK = 3,
    MOVE_LAND_WALK  = 4,
};

enum PlayerSpeedType
{
    RUN	            = 1,
    RUNBACK         = 2,
    SWIM	        = 3,
    SWIMBACK        = 4,
    WALK	        = 5,
    FLY	            = 6,
};

enum Standing
{
    STANDING_HATED,
    STANDING_HOSTILE,
    STANDING_UNFRIENDLY,
    STANDING_NEUTRAL,
    STANDING_FRIENDLY,
    STANDING_HONORED,
    STANDING_REVERED,
    STANDING_EXALTED
};

enum PlayerFlags
{
    PLAYER_FLAG_PARTY_LEADER		= 0x000001,
    PLAYER_FLAG_AFK					= 0x000002,
    PLAYER_FLAG_DND					= 0x000004,
    PLAYER_FLAG_GM					= 0x000008,
    PLAYER_FLAG_DEATH_WORLD_ENABLE  = 0x000010,
    PLAYER_FLAG_RESTING				= 0x000020,
    PLAYER_FLAG_UNKNOWN1            = 0x000040,
    PLAYER_FLAG_FREE_FOR_ALL_PVP	= 0x000080,
    PLAYER_FLAG_UNKNOWN2            = 0x000100,
    PLAYER_FLAG_PVP_TOGGLE			= 0x000200,
    PLAYER_FLAG_NOHELM				= 0x000400,
    PLAYER_FLAG_NOCLOAK				= 0x000800,
    PLAYER_FLAG_NEED_REST_3_HOURS	= 0x001000,
    PLAYER_FLAG_NEED_REST_5_HOURS	= 0x002000,
	PLAYER_FLAG_PVP_TIMER			= 0x040000,	
};

enum CharterTypes
{
	CHARTER_TYPE_GUILD			= 0,
	CHARTER_TYPE_ARENA_2V2		= 1,
	CHARTER_TYPE_ARENA_3V3		= 2,
	CHARTER_TYPE_ARENA_5V5		= 3,
	NUM_CHARTER_TYPES			= 4,
};

enum ArenaTeamTypes
{
	ARENA_TEAM_TYPE_2V2			= 0,
	ARENA_TEAM_TYPE_3V3			= 1,
	ARENA_TEAM_TYPE_5V5			= 2,
	NUM_ARENA_TEAM_TYPES		= 3,
};

enum CooldownTypes
{
	COOLDOWN_TYPE_SPELL			= 0,
	COOLDOWN_TYPE_CATEGORY		= 1,
	NUM_COOLDOWN_TYPES,
};

enum LootType
{
    LOOT_CORPSE                 = 1,
    LOOT_SKINNING               = 2,
    LOOT_FISHING                = 3,
    LOOT_PICKPOCKETING          = 2,                        // 4 unsupported by client, sending LOOT_SKINNING instead
    LOOT_DISENCHANTING          = 2,                        // 5 unsupported by client, sending LOOT_SKINNING instead
    LOOT_PROSPECTING            = 2,                        // 6 unsupported by client, sending LOOT_SKINNING instead
	LOOT_INSIGNIA               = 2,                        // 7 unsupported by client, sending LOOT_SKINNING instead
	LOOT_MILLING				= 2                         // 7 unsupported by client, sending LOOT_SKINNING instead
};

struct spells
{
	uint16  spellId;
	uint16  slotId;
};

#pragma pack(push,1)
struct ActionButton
{
	uint16  Action;
	uint8   Misc;
	uint8   Type;
};
#pragma pack(pop)

struct CreateInfo_ItemStruct
{
	uint32  protoid;
	uint8   slot;
	uint32  amount;
};

struct CreateInfo_SkillStruct
{
	uint32  skillid;
	uint32  currentval;
	uint32  maxval;
};

struct CreateInfo_ActionBarStruct
{
	uint32  button;
	uint32  action;
	uint32  type;
	uint32  misc;
};

struct PlayerCreateInfo{
	uint8   index;
	uint8   race;
	uint32  factiontemplate;
	uint8   class_;
	uint32  mapId;
	uint32  zoneId;
	float   positionX;
	float   positionY;
	float   positionZ;
	uint16  displayId;
	uint8   strength;
	uint8   ability;
	uint8   stamina;
	uint8   intellect;
	uint8   spirit;
	uint32  health;
	uint32  mana;
	uint32  rage;
	uint32  focus;
	uint32  energy;
	uint32  runic;
	uint32  attackpower;
	float   mindmg;
	float   maxdmg;
	std::list<CreateInfo_ItemStruct> items;
	std::list<CreateInfo_SkillStruct> skills;
	std::list<CreateInfo_ActionBarStruct> actionbars;
	std::set<uint32> spell_list;
	//uint32 item[10];
	//uint8 item_slot[10];
	//uint16 spell[10];
};

struct DamageSplit
{
	Player* caster;
	Aura*   aura;
	uint32  miscVal;
	union
	{
		uint32 damage;
		float damagePCT;
	};
};

struct LoginAura
{
    uint32 id;
    int32 dur;
	uint32 m_flags;	
};

// OpenAscent 3.20
static const uint32 TalentTreesPerClass[DRUID+1][3] =  {
	{ 0, 0, 0 },		// NONE
	{ 161, 163, 164 },	// WARRIOR
	{ 382, 383, 381 },	// PALADIN
	{ 361, 363, 362 },	// HUNTER
	{ 182, 181, 183 },	// ROGUE
	{ 201, 202, 203 },	// PRIEST
	{ 398, 399, 400 },	// DEATH KNIGHT
	{ 261, 263, 262 },	// SHAMAN
	{ 81, 41, 61 },		// MAGE
	{ 302, 303, 301 },	// WARLOCK
	{ 0, 0, 0 },		// NONE
	{ 283, 281, 282 },	// DRUID
};

// Dodge ( class base ) -   UNUSED, Warrior, Paladin,  Hunter,   Rogue,   Priest, DeathKnight, Shaman, Mage,   Warlock, UNUSED, Druid
const float baseDodge[12] = { 0.0f, 0.7580f, 0.6520f, -5.4500f, -0.5900f, 3.1830f, 0.7580f  , 1.6750f, 3.4575f, 2.0350f, 0.0f, -1.8720f };

// Dodge ( class ratio ) - UNUSED, Warrior, Paladin, Hunter, Rogue, Priest, DeathKnight, Shaman, Mage, Warlock, UNUSED, Druid
// TODO: get proper ratios for all levels, we only have values for level 70 currently and appropriated values for < 70 through a PHP script >_<
const float dodgeRatio[250][12] = {
{ 0.000000f , 5.000000f , 5.000000f , 5.000000f , 5.000000f , 5.000000f , 0.000000f , 5.000000f , 5.000000f , 5.000000f , 0.000000f , 5.000000f , } , // Level 1 
{ 0.000000f , 5.000000f , 5.000000f , 5.000000f , 5.000000f , 5.000000f , 0.000000f , 5.000000f , 5.000000f , 5.000000f , 0.000000f , 5.000000f , } , // Level 2 
{ 0.000000f , 5.157590f , 5.000000f , 5.000000f , 5.000000f , 5.000000f , 0.000000f , 5.000000f , 5.000000f , 5.000000f , 0.000000f , 5.000000f , } , // Level 3 
{ 0.000000f , 6.017188f , 5.014323f , 5.014323f , 5.000000f , 5.014323f , 0.000000f , 5.014323f , 5.014323f , 5.014323f , 0.000000f , 5.000000f , } , // Level 4 
{ 0.000000f , 6.793599f , 5.661333f , 5.661333f , 5.000000f , 5.661333f , 0.000000f , 5.661333f , 5.661333f , 5.661333f , 0.000000f , 5.000000f , } , // Level 5 
{ 0.000000f , 7.508715f , 6.257262f , 6.257262f , 5.005810f , 6.257262f , 0.000000f , 6.257262f , 6.257262f , 6.257262f , 0.000000f , 5.000000f , } , // Level 6 
{ 0.000000f , 8.176156f , 6.813463f , 6.813463f , 5.450771f , 6.813463f , 0.000000f , 6.813463f , 6.813463f , 6.813463f , 0.000000f , 5.000000f , } , // Level 7 
{ 0.000000f , 8.805091f , 7.337576f , 7.337576f , 5.870061f , 7.337576f , 0.000000f , 7.337576f , 7.337576f , 7.337576f , 0.000000f , 5.000000f , } , // Level 8 
{ 0.000000f , 9.402047f , 7.835039f , 7.835039f , 6.268031f , 7.835039f , 0.000000f , 7.835039f , 7.835039f , 7.835039f , 0.000000f , 5.000000f , } , // Level 9 
{ 0.000000f , 9.971868f , 8.309890f , 8.309890f , 6.647912f , 8.309890f , 0.000000f , 8.309890f , 8.309890f , 8.309890f , 0.000000f , 5.000000f , } , // Level 10 
{ 0.000000f , 10.518271f , 8.765226f , 8.765226f , 7.012181f , 8.765226f , 0.000000f , 8.765226f , 8.765226f , 8.765226f , 0.000000f , 5.156022f , } , // Level 11 
{ 0.000000f , 11.044185f , 9.203487f , 9.203487f , 7.362790f , 9.203487f , 0.000000f , 9.203487f , 9.203487f , 9.203487f , 0.000000f , 5.413823f , } , // Level 12 
{ 0.000000f , 11.551964f , 9.626636f , 9.626636f , 7.701309f , 9.626636f , 0.000000f , 9.626636f , 9.626636f , 9.626636f , 0.000000f , 5.662734f , } , // Level 13 
{ 0.000000f , 12.043536f , 10.036280f , 10.036280f , 8.029024f , 10.036280f , 0.000000f , 10.036280f , 10.036280f , 10.036280f , 0.000000f , 5.903701f , } , // Level 14 
{ 0.000000f , 12.520508f , 10.433757f , 10.433757f , 8.347005f , 10.433757f , 0.000000f , 10.433757f , 10.433757f , 10.433757f , 0.000000f , 6.137511f , } , // Level 15 
{ 0.000000f , 12.984231f , 10.820192f , 10.820192f , 8.656154f , 10.820192f , 0.000000f , 10.820192f , 10.820192f , 10.820192f , 0.000000f , 6.364827f , } , // Level 16 
{ 0.000000f , 13.435856f , 11.196547f , 11.196547f , 8.957237f , 11.196547f , 0.000000f , 11.196547f , 11.196547f , 11.196547f , 0.000000f , 6.586212f , } , // Level 17 
{ 0.000000f , 13.876376f , 11.563647f , 11.563647f , 9.250917f , 11.563647f , 0.000000f , 11.563647f , 11.563647f , 11.563647f , 0.000000f , 6.802153f , } , // Level 18 
{ 0.000000f , 14.306651f , 11.922209f , 11.922209f , 9.537767f , 11.922209f , 0.000000f , 11.922209f , 11.922209f , 11.922209f , 0.000000f , 7.013073f , } , // Level 19 
{ 0.000000f , 14.727435f , 12.272863f , 12.272863f , 9.818290f , 12.272863f , 0.000000f , 12.272863f , 12.272863f , 12.272863f , 0.000000f , 7.219340f , } , // Level 20 
{ 0.000000f , 15.139391f , 12.616159f , 12.616159f , 10.092928f , 12.616159f , 0.000000f , 12.616159f , 12.616159f , 12.616159f , 0.000000f , 7.421279f , } , // Level 21 
{ 0.000000f , 15.543108f , 12.952590f , 12.952590f , 10.362072f , 12.952590f , 0.000000f , 12.952590f , 12.952590f , 12.952590f , 0.000000f , 7.619180f , } , // Level 22 
{ 0.000000f , 15.939111f , 13.282593f , 13.282593f , 10.626074f , 13.282593f , 0.000000f , 13.282593f , 13.282593f , 13.282593f , 0.000000f , 7.813299f , } , // Level 23 
{ 0.000000f , 16.327870f , 13.606558f , 13.606558f , 10.885247f , 13.606558f , 0.000000f , 13.606558f , 13.606558f , 13.606558f , 0.000000f , 8.003867f , } , // Level 24 
{ 0.000000f , 16.709808f , 13.924840f , 13.924840f , 11.139872f , 13.924840f , 0.000000f , 13.924840f , 13.924840f , 13.924840f , 0.000000f , 8.191092f , } , // Level 25 
{ 0.000000f , 17.085310f , 14.237758f , 14.237758f , 11.390207f , 14.237758f , 0.000000f , 14.237758f , 14.237758f , 14.237758f , 0.000000f , 8.375162f , } , // Level 26 
{ 0.000000f , 17.454722f , 14.545602f , 14.545602f , 11.636481f , 14.545602f , 0.000000f , 14.545602f , 14.545602f , 14.545602f , 0.000000f , 8.556246f , } , // Level 27 
{ 0.000000f , 17.818362f , 14.848635f , 14.848635f , 11.878908f , 14.848635f , 0.000000f , 14.848635f , 14.848635f , 14.848635f , 0.000000f , 8.734502f , } , // Level 28 
{ 0.000000f , 18.176520f , 15.147100f , 15.147100f , 12.117680f , 15.147100f , 0.000000f , 15.147100f , 15.147100f , 15.147100f , 0.000000f , 8.910069f , } , // Level 29 
{ 0.000000f , 18.529462f , 15.441218f , 15.441218f , 12.352975f , 15.441218f , 0.000000f , 15.441218f , 15.441218f , 15.441218f , 0.000000f , 9.083081f , } , // Level 30 
{ 0.000000f , 18.877433f , 15.731194f , 15.731194f , 12.584955f , 15.731194f , 0.000000f , 15.731194f , 15.731194f , 15.731194f , 0.000000f , 9.253655f , } , // Level 31 
{ 0.000000f , 19.220659f , 16.017216f , 16.017216f , 12.813773f , 16.017216f , 0.000000f , 16.017216f , 16.017216f , 16.017216f , 0.000000f , 9.421903f , } , // Level 32 
{ 0.000000f , 19.559349f , 16.299458f , 16.299458f , 13.039566f , 16.299458f , 0.000000f , 16.299458f , 16.299458f , 16.299458f , 0.000000f , 9.587928f , } , // Level 33 
{ 0.000000f , 19.893697f , 16.578081f , 16.578081f , 13.262465f , 16.578081f , 0.000000f , 16.578081f , 16.578081f , 16.578081f , 0.000000f , 9.751824f , } , // Level 34 
{ 0.000000f , 20.223883f , 16.853236f , 16.853236f , 13.482589f , 16.853236f , 0.000000f , 16.853236f , 16.853236f , 16.853236f , 0.000000f , 9.913680f , } , // Level 35 
{ 0.000000f , 20.550075f , 17.125062f , 17.125062f , 13.700050f , 17.125062f , 0.000000f , 17.125062f , 17.125062f , 17.125062f , 0.000000f , 10.073578f , } , // Level 36 
{ 0.000000f , 20.872429f , 17.393691f , 17.393691f , 13.914953f , 17.393691f , 0.000000f , 17.393691f , 17.393691f , 17.393691f , 0.000000f , 10.231595f , } , // Level 37 
{ 0.000000f , 21.191092f , 17.659243f , 17.659243f , 14.127395f , 17.659243f , 0.000000f , 17.659243f , 17.659243f , 17.659243f , 0.000000f , 10.387803f , } , // Level 38 
{ 0.000000f , 21.506201f , 17.921834f , 17.921834f , 14.337467f , 17.921834f , 0.000000f , 17.921834f , 17.921834f , 17.921834f , 0.000000f , 10.542268f , } , // Level 39 
{ 0.000000f , 21.817885f , 18.181571f , 18.181571f , 14.545257f , 18.181571f , 0.000000f , 18.181571f , 18.181571f , 18.181571f , 0.000000f , 10.695055f , } , // Level 40 
{ 0.000000f , 22.126265f , 18.438554f , 18.438554f , 14.750843f , 18.438554f , 0.000000f , 18.438554f , 18.438554f , 18.438554f , 0.000000f , 10.846221f , } , // Level 41 
{ 0.000000f , 22.431455f , 18.692879f , 18.692879f , 14.954303f , 18.692879f , 0.000000f , 18.692879f , 18.692879f , 18.692879f , 0.000000f , 10.995824f , } , // Level 42 
{ 0.000000f , 22.733562f , 18.944635f , 18.944635f , 15.155708f , 18.944635f , 0.000000f , 18.944635f , 18.944635f , 18.944635f , 0.000000f , 11.143916f , } , // Level 43 
{ 0.000000f , 23.032688f , 19.193907f , 19.193907f , 15.355125f , 19.193907f , 0.000000f , 19.193907f , 19.193907f , 19.193907f , 0.000000f , 11.290547f , } , // Level 44 
{ 0.000000f , 23.328928f , 19.440774f , 19.440774f , 15.552619f , 19.440774f , 0.000000f , 19.440774f , 19.440774f , 19.440774f , 0.000000f , 11.435763f , } , // Level 45 
{ 0.000000f , 23.622374f , 19.685312f , 19.685312f , 15.748249f , 19.685312f , 0.000000f , 19.685312f , 19.685312f , 19.685312f , 0.000000f , 11.579609f , } , // Level 46 
{ 0.000000f , 23.913111f , 19.927592f , 19.927592f , 15.942074f , 19.927592f , 0.000000f , 19.927592f , 19.927592f , 19.927592f , 0.000000f , 11.722127f , } , // Level 47 
{ 0.000000f , 24.201221f , 20.167684f , 20.167684f , 16.134147f , 20.167684f , 0.000000f , 20.167684f , 20.167684f , 20.167684f , 0.000000f , 11.863358f , } , // Level 48 
{ 0.000000f , 24.486781f , 20.405651f , 20.405651f , 16.324520f , 20.405651f , 0.000000f , 20.405651f , 20.405651f , 20.405651f , 0.000000f , 12.003338f , } , // Level 49 
{ 0.000000f , 24.769865f , 20.641554f , 20.641554f , 16.513243f , 20.641554f , 0.000000f , 20.641554f , 20.641554f , 20.641554f , 0.000000f , 12.142105f , } , // Level 50 
{ 0.000000f , 25.050543f , 20.875453f , 20.875453f , 16.700362f , 20.875453f , 0.000000f , 20.875453f , 20.875453f , 20.875453f , 0.000000f , 12.279693f , } , // Level 51 
{ 0.000000f , 25.328883f , 21.107402f , 21.107402f , 16.885922f , 21.107402f , 0.000000f , 21.107402f , 21.107402f , 21.107402f , 0.000000f , 12.416134f , } , // Level 52 
{ 0.000000f , 25.604947f , 21.337456f , 21.337456f , 17.069964f , 21.337456f , 0.000000f , 21.337456f , 21.337456f , 21.337456f , 0.000000f , 12.551460f , } , // Level 53 
{ 0.000000f , 25.878796f , 21.565664f , 21.565664f , 17.252531f , 21.565664f , 0.000000f , 21.565664f , 21.565664f , 21.565664f , 0.000000f , 12.685700f , } , // Level 54 
{ 0.000000f , 26.150490f , 21.792075f , 21.792075f , 17.433660f , 21.792075f , 0.000000f , 21.792075f , 21.792075f , 21.792075f , 0.000000f , 12.818883f , } , // Level 55 
{ 0.000000f , 26.420082f , 22.016735f , 22.016735f , 17.613388f , 22.016735f , 0.000000f , 22.016735f , 22.016735f , 22.016735f , 0.000000f , 12.951036f , } , // Level 56 
{ 0.000000f , 26.687628f , 22.239690f , 22.239690f , 17.791752f , 22.239690f , 0.000000f , 22.239690f , 22.239690f , 22.239690f , 0.000000f , 13.082186f , } , // Level 57 
{ 0.000000f , 26.953176f , 22.460980f , 22.460980f , 17.968784f , 22.460980f , 0.000000f , 22.460980f , 22.460980f , 22.460980f , 0.000000f , 13.212357f , } , // Level 58 
{ 0.000000f , 27.216777f , 22.680647f , 22.680647f , 18.144518f , 22.680647f , 0.000000f , 22.680647f , 22.680647f , 22.680647f , 0.000000f , 13.341573f , } , // Level 59 
{ 0.000000f , 27.478477f , 22.898731f , 22.898731f , 18.318984f , 22.898731f , 0.000000f , 22.898731f , 22.898731f , 22.898731f , 0.000000f , 13.469858f , } , // Level 60
//BC
{ 0.000000f , 27.738320f , 23.115267f , 23.115267f , 18.492214f , 23.115267f , 0.000000f , 23.115267f , 23.115267f , 23.115267f , 0.000000f , 13.597232f , } , // Level 61 
{ 0.000000f , 27.996351f , 23.330293f , 23.330293f , 18.664234f , 23.330293f , 0.000000f , 23.330293f , 23.330293f , 23.330293f , 0.000000f , 13.723718f , } , // Level 62 
{ 0.000000f , 28.252611f , 23.543842f , 23.543842f , 18.835074f , 23.543842f , 0.000000f , 23.543842f , 23.543842f , 23.543842f , 0.000000f , 13.849336f , } , // Level 63 
{ 0.000000f , 28.507139f , 23.755949f , 23.755949f , 19.004759f , 23.755949f , 0.000000f , 23.755949f , 23.755949f , 23.755949f , 0.000000f , 13.974104f , } , // Level 64 
{ 0.000000f , 28.759974f , 23.966645f , 23.966645f , 19.173316f , 23.966645f , 0.000000f , 23.966645f , 23.966645f , 23.966645f , 0.000000f , 14.098043f , } , // Level 65 
{ 0.000000f , 29.011153f , 24.175960f , 24.175960f , 19.340768f , 24.175960f , 0.000000f , 24.175960f , 24.175960f , 24.175960f , 0.000000f , 14.221170f , } , // Level 66 
{ 0.000000f , 29.260711f , 24.383926f , 24.383926f , 19.507141f , 24.383926f , 0.000000f , 24.383926f , 24.383926f , 24.383926f , 0.000000f , 14.343503f , } , // Level 67 
{ 0.000000f , 29.508683f , 24.590569f , 24.590569f , 19.672455f , 24.590569f , 0.000000f , 24.590569f , 24.590569f , 24.590569f , 0.000000f , 14.465058f , } , // Level 68 
{ 0.000000f , 29.755102f , 24.795918f , 24.795918f , 19.836735f , 24.795918f , 0.000000f , 24.795918f , 24.795918f , 24.795918f , 0.000000f , 14.585852f , } , // Level 69 
{ 0.000000f , 30.000000f , 25.000000f , 25.000000f , 20.000000f , 25.000000f , 0.000000f , 25.000000f , 25.000000f , 25.000000f , 0.000000f , 14.705900f , } , // Level 70  
// Ajout WaadTeam, pas sur des valeurs, le calcul est fait sur l'ecart entre les 5 ou 6 dernieres valeurs
// WOTLK
{ 0.000000f, 30.392937f, 25.247465f, 25.247465f, 20.331737f, 25.247465f, 30.392937f, 25.247465f, 25.247465f, 25.247465f, 0.000000f, 14.888249f }, // Level 71
{ 0.000000f, 30.785875f, 25.494930f, 25.494930f, 20.663474f, 25.494930f, 30.785875f, 25.494930f, 25.494930f, 25.494930f, 0.000000f, 15.070598f }, // Level 72
{ 0.000000f, 31.178813f, 25.742395f, 25.742395f, 20.995211f, 25.742395f, 31.178813f, 25.742395f, 25.742395f, 25.742395f, 0.000000f, 15.252947f }, // Level 73
{ 0.000000f, 31.571751f, 25.989861f, 25.989861f, 21.326948f, 25.989861f, 31.571751f, 25.989861f, 25.989861f, 25.989861f, 0.000000f, 15.435296f }, // Level 74
{ 0.000000f, 31.964689f, 26.237326f, 26.237326f, 21.658685f, 26.237326f, 31.964689f, 26.237326f, 26.237326f, 26.237326f, 0.000000f, 15.617645f }, // Level 75
{ 0.000000f, 32.357627f, 26.484791f, 26.484791f, 21.990422f, 26.484791f, 32.357627f, 26.484791f, 26.484791f, 26.484791f, 0.000000f, 15.799994f }, // Level 76
{ 0.000000f, 32.750565f, 26.732256f, 26.732256f, 22.322159f, 26.732256f, 32.750565f, 26.732256f, 26.732256f, 26.732256f, 0.000000f, 15.982343f }, // Level 77
{ 0.000000f, 33.143503f, 26.979722f, 26.979722f, 22.653896f, 26.979722f, 33.143503f, 26.979722f, 26.979722f, 26.979722f, 0.000000f, 16.164692f }, // Level 78
{ 0.000000f, 33.536441f, 27.227187f, 27.227187f, 22.985633f, 27.227187f, 33.536441f, 27.227187f, 27.227187f, 27.227187f, 0.000000f, 16.347041f }, // Level 79
{ 0.000000f, 33.929379f, 27.474652f, 27.474652f, 23.317370f, 27.474652f, 33.929379f, 27.474652f, 27.474652f, 27.474652f, 0.000000f, 16.529390f }, // Level 80
// prochaine extension
{ 0.000000f, 34.322317f, 27.722118f, 27.722118f, 23.649107f, 27.722118f, 34.322317f, 27.722118f, 27.722118f, 27.722118f, 0.000000f, 16.711739f }, // Level 81
{ 0.000000f, 34.715255f, 27.969583f, 27.969583f, 23.980844f, 27.969583f, 34.715255f, 27.969583f, 27.969583f, 27.969583f, 0.000000f, 16.894088f }, // Level 82
{ 0.000000f, 35.108192f, 28.217048f, 28.217048f, 24.312581f, 28.217048f, 35.108192f, 28.217048f, 28.217048f, 28.217048f, 0.000000f, 17.076437f }, // Level 83
{ 0.000000f, 35.501130f, 28.464513f, 28.464513f, 24.644318f, 28.464513f, 35.501130f, 28.464513f, 28.464513f, 28.464513f, 0.000000f, 17.258786f }, // Level 84
{ 0.000000f, 35.894068f, 28.711979f, 28.711979f, 24.976055f, 28.711979f, 35.894068f, 28.711979f, 28.711979f, 28.711979f, 0.000000f, 17.441135f }, // Level 85
{ 0.000000f, 36.287006f, 28.959444f, 28.959444f, 25.307792f, 28.959444f, 36.287006f, 28.959444f, 28.959444f, 28.959444f, 0.000000f, 17.623484f }, // Level 86
{ 0.000000f, 36.679944f, 29.206909f, 29.206909f, 25.639529f, 29.206909f, 36.679944f, 29.206909f, 29.206909f, 29.206909f, 0.000000f, 17.805833f }, // Level 87
{ 0.000000f, 37.072882f, 29.454375f, 29.454375f, 25.971266f, 29.454375f, 37.072882f, 29.454375f, 29.454375f, 29.454375f, 0.000000f, 17.988182f }, // Level 88
{ 0.000000f, 37.465820f, 29.701840f, 29.701840f, 26.303003f, 29.701840f, 37.465820f, 29.701840f, 29.701840f, 29.701840f, 0.000000f, 18.170531f }, // Level 89
{ 0.000000f, 37.858758f, 29.949305f, 29.949305f, 26.634740f, 29.949305f, 37.858758f, 29.949305f, 29.949305f, 29.949305f, 0.000000f, 18.352880f }, // Level 90
// up from 91 to 250 ;)
{ 0.000000f, 38.251696f, 30.196770f, 30.196770f, 26.966477f, 30.196770f, 38.251696f, 30.196770f, 30.196770f, 30.196770f, 0.000000f, 18.535229f }, // Level 91
{ 0.000000f, 38.644634f, 30.444236f, 30.444236f, 27.298214f, 30.444236f, 38.644634f, 30.444236f, 30.444236f, 30.444236f, 0.000000f, 18.717578f }, // Level 92
{ 0.000000f, 39.037572f, 30.691701f, 30.691701f, 27.629951f, 30.691701f, 39.037572f, 30.691701f, 30.691701f, 30.691701f, 0.000000f, 18.899927f }, // Level 93
{ 0.000000f, 39.430510f, 30.939166f, 30.939166f, 27.961688f, 30.939166f, 39.430510f, 30.939166f, 30.939166f, 30.939166f, 0.000000f, 19.082276f }, // Level 94
{ 0.000000f, 39.823448f, 31.186632f, 31.186632f, 28.293425f, 31.186632f, 39.823448f, 31.186632f, 31.186632f, 31.186632f, 0.000000f, 19.264625f }, // Level 95
{ 0.000000f, 40.216385f, 31.434097f, 31.434097f, 28.625162f, 31.434097f, 40.216385f, 31.434097f, 31.434097f, 31.434097f, 0.000000f, 19.446974f }, // Level 96
{ 0.000000f, 40.609323f, 31.681562f, 31.681562f, 28.956899f, 31.681562f, 40.609323f, 31.681562f, 31.681562f, 31.681562f, 0.000000f, 19.629323f }, // Level 97
{ 0.000000f, 41.002261f, 31.929027f, 31.929027f, 29.288636f, 31.929027f, 41.002261f, 31.929027f, 31.929027f, 31.929027f, 0.000000f, 19.811672f }, // Level 98
{ 0.000000f, 41.395199f, 32.176493f, 32.176493f, 29.620373f, 32.176493f, 41.395199f, 32.176493f, 32.176493f, 32.176493f, 0.000000f, 19.994021f }, // Level 99
{ 0.000000f, 41.788137f, 32.423958f, 32.423958f, 29.952110f, 32.423958f, 41.788137f, 32.423958f, 32.423958f, 32.423958f, 0.000000f, 20.176370f }, // Level 100
{ 0.000000f, 42.181075f, 32.671423f, 32.671423f, 30.283847f, 32.671423f, 42.181075f, 32.671423f, 32.671423f, 32.671423f, 0.000000f, 20.358719f }, // Level 101
{ 0.000000f, 42.574013f, 32.918888f, 32.918888f, 30.615584f, 32.918888f, 42.574013f, 32.918888f, 32.918888f, 32.918888f, 0.000000f, 20.541068f }, // Level 102
{ 0.000000f, 42.966951f, 33.166354f, 33.166354f, 30.947321f, 33.166354f, 42.966951f, 33.166354f, 33.166354f, 33.166354f, 0.000000f, 20.723417f }, // Level 103
{ 0.000000f, 43.359889f, 33.413819f, 33.413819f, 31.279058f, 33.413819f, 43.359889f, 33.413819f, 33.413819f, 33.413819f, 0.000000f, 20.905766f }, // Level 104
{ 0.000000f, 43.752827f, 33.661284f, 33.661284f, 31.610795f, 33.661284f, 43.752827f, 33.661284f, 33.661284f, 33.661284f, 0.000000f, 21.088115f }, // Level 105
{ 0.000000f, 44.145765f, 33.908750f, 33.908750f, 31.942532f, 33.908750f, 44.145765f, 33.908750f, 33.908750f, 33.908750f, 0.000000f, 21.270464f }, // Level 106
{ 0.000000f, 44.538703f, 34.156215f, 34.156215f, 32.274269f, 34.156215f, 44.538703f, 34.156215f, 34.156215f, 34.156215f, 0.000000f, 21.452813f }, // Level 107
{ 0.000000f, 44.931641f, 34.403680f, 34.403680f, 32.606006f, 34.403680f, 44.931641f, 34.403680f, 34.403680f, 34.403680f, 0.000000f, 21.635162f }, // Level 108
{ 0.000000f, 45.324578f, 34.651145f, 34.651145f, 32.937743f, 34.651145f, 45.324578f, 34.651145f, 34.651145f, 34.651145f, 0.000000f, 21.817511f }, // Level 109
{ 0.000000f, 45.717516f, 34.898611f, 34.898611f, 33.269480f, 34.898611f, 45.717516f, 34.898611f, 34.898611f, 34.898611f, 0.000000f, 21.999860f }, // Level 110
{ 0.000000f, 46.110454f, 35.146076f, 35.146076f, 33.601217f, 35.146076f, 46.110454f, 35.146076f, 35.146076f, 35.146076f, 0.000000f, 22.182209f }, // Level 111
{ 0.000000f, 46.503392f, 35.393541f, 35.393541f, 33.932954f, 35.393541f, 46.503392f, 35.393541f, 35.393541f, 35.393541f, 0.000000f, 22.364558f }, // Level 112
{ 0.000000f, 46.896330f, 35.641007f, 35.641007f, 34.264691f, 35.641007f, 46.896330f, 35.641007f, 35.641007f, 35.641007f, 0.000000f, 22.546907f }, // Level 113
{ 0.000000f, 47.289268f, 35.888472f, 35.888472f, 34.596428f, 35.888472f, 47.289268f, 35.888472f, 35.888472f, 35.888472f, 0.000000f, 22.729256f }, // Level 114
{ 0.000000f, 47.682206f, 36.135937f, 36.135937f, 34.928165f, 36.135937f, 47.682206f, 36.135937f, 36.135937f, 36.135937f, 0.000000f, 22.911605f }, // Level 115
{ 0.000000f, 48.075144f, 36.383402f, 36.383402f, 35.259902f, 36.383402f, 48.075144f, 36.383402f, 36.383402f, 36.383402f, 0.000000f, 23.093954f }, // Level 116
{ 0.000000f, 48.468082f, 36.630868f, 36.630868f, 35.591639f, 36.630868f, 48.468082f, 36.630868f, 36.630868f, 36.630868f, 0.000000f, 23.276303f }, // Level 117
{ 0.000000f, 48.861020f, 36.878333f, 36.878333f, 35.923376f, 36.878333f, 48.861020f, 36.878333f, 36.878333f, 36.878333f, 0.000000f, 23.458652f }, // Level 118
{ 0.000000f, 49.253958f, 37.125798f, 37.125798f, 36.255113f, 37.125798f, 49.253958f, 37.125798f, 37.125798f, 37.125798f, 0.000000f, 23.641001f }, // Level 119
{ 0.000000f, 49.646896f, 37.373264f, 37.373264f, 36.586850f, 37.373264f, 49.646896f, 37.373264f, 37.373264f, 37.373264f, 0.000000f, 23.823350f }, // Level 120
{ 0.000000f, 50.039834f, 37.620729f, 37.620729f, 36.918587f, 37.620729f, 50.039834f, 37.620729f, 37.620729f, 37.620729f, 0.000000f, 24.005699f }, // Level 121
{ 0.000000f, 50.432771f, 37.868194f, 37.868194f, 37.250324f, 37.868194f, 50.432771f, 37.868194f, 37.868194f, 37.868194f, 0.000000f, 24.188048f }, // Level 122
{ 0.000000f, 50.825709f, 38.115659f, 38.115659f, 37.582061f, 38.115659f, 50.825709f, 38.115659f, 38.115659f, 38.115659f, 0.000000f, 24.370397f }, // Level 123
{ 0.000000f, 51.218647f, 38.363125f, 38.363125f, 37.913798f, 38.363125f, 51.218647f, 38.363125f, 38.363125f, 38.363125f, 0.000000f, 24.552746f }, // Level 124
{ 0.000000f, 51.611585f, 38.610590f, 38.610590f, 38.245535f, 38.610590f, 51.611585f, 38.610590f, 38.610590f, 38.610590f, 0.000000f, 24.735095f }, // Level 125
{ 0.000000f, 52.004523f, 38.858055f, 38.858055f, 38.577272f, 38.858055f, 52.004523f, 38.858055f, 38.858055f, 38.858055f, 0.000000f, 24.917444f }, // Level 126
{ 0.000000f, 52.397461f, 39.105520f, 39.105520f, 38.909009f, 39.105520f, 52.397461f, 39.105520f, 39.105520f, 39.105520f, 0.000000f, 25.099793f }, // Level 127
{ 0.000000f, 52.790399f, 39.352986f, 39.352986f, 39.240746f, 39.352986f, 52.790399f, 39.352986f, 39.352986f, 39.352986f, 0.000000f, 25.282142f }, // Level 128
{ 0.000000f, 53.183337f, 39.600451f, 39.600451f, 39.572483f, 39.600451f, 53.183337f, 39.600451f, 39.600451f, 39.600451f, 0.000000f, 25.464491f }, // Level 129
{ 0.000000f, 53.576275f, 39.847916f, 39.847916f, 39.904220f, 39.847916f, 53.576275f, 39.847916f, 39.847916f, 39.847916f, 0.000000f, 25.646840f }, // Level 130
{ 0.000000f, 53.969213f, 40.095382f, 40.095382f, 40.235957f, 40.095382f, 53.969213f, 40.095382f, 40.095382f, 40.095382f, 0.000000f, 25.829189f }, // Level 131
{ 0.000000f, 54.362151f, 40.342847f, 40.342847f, 40.567694f, 40.342847f, 54.362151f, 40.342847f, 40.342847f, 40.342847f, 0.000000f, 26.011538f }, // Level 132
{ 0.000000f, 54.755089f, 40.590312f, 40.590312f, 40.899431f, 40.590312f, 54.755089f, 40.590312f, 40.590312f, 40.590312f, 0.000000f, 26.193887f }, // Level 133
{ 0.000000f, 55.148027f, 40.837777f, 40.837777f, 41.231168f, 40.837777f, 55.148027f, 40.837777f, 40.837777f, 40.837777f, 0.000000f, 26.376236f }, // Level 134
{ 0.000000f, 55.540964f, 41.085243f, 41.085243f, 41.562905f, 41.085243f, 55.540964f, 41.085243f, 41.085243f, 41.085243f, 0.000000f, 26.558585f }, // Level 135
{ 0.000000f, 55.933902f, 41.332708f, 41.332708f, 41.894642f, 41.332708f, 55.933902f, 41.332708f, 41.332708f, 41.332708f, 0.000000f, 26.740934f }, // Level 136
{ 0.000000f, 56.326840f, 41.580173f, 41.580173f, 42.226379f, 41.580173f, 56.326840f, 41.580173f, 41.580173f, 41.580173f, 0.000000f, 26.923283f }, // Level 137
{ 0.000000f, 56.719778f, 41.827639f, 41.827639f, 42.558116f, 41.827639f, 56.719778f, 41.827639f, 41.827639f, 41.827639f, 0.000000f, 27.105632f }, // Level 138
{ 0.000000f, 57.112716f, 42.075104f, 42.075104f, 42.889853f, 42.075104f, 57.112716f, 42.075104f, 42.075104f, 42.075104f, 0.000000f, 27.287981f }, // Level 139
{ 0.000000f, 57.505654f, 42.322569f, 42.322569f, 43.221590f, 42.322569f, 57.505654f, 42.322569f, 42.322569f, 42.322569f, 0.000000f, 27.470330f }, // Level 140
{ 0.000000f, 57.898592f, 42.570034f, 42.570034f, 43.553327f, 42.570034f, 57.898592f, 42.570034f, 42.570034f, 42.570034f, 0.000000f, 27.652679f }, // Level 141
{ 0.000000f, 58.291530f, 42.817500f, 42.817500f, 43.885064f, 42.817500f, 58.291530f, 42.817500f, 42.817500f, 42.817500f, 0.000000f, 27.835028f }, // Level 142
{ 0.000000f, 58.684468f, 43.064965f, 43.064965f, 44.216801f, 43.064965f, 58.684468f, 43.064965f, 43.064965f, 43.064965f, 0.000000f, 28.017377f }, // Level 143
{ 0.000000f, 59.077406f, 43.312430f, 43.312430f, 44.548538f, 43.312430f, 59.077406f, 43.312430f, 43.312430f, 43.312430f, 0.000000f, 28.199726f }, // Level 144
{ 0.000000f, 59.470344f, 43.559896f, 43.559896f, 44.880275f, 43.559896f, 59.470344f, 43.559896f, 43.559896f, 43.559896f, 0.000000f, 28.382075f }, // Level 145
{ 0.000000f, 59.863282f, 43.807361f, 43.807361f, 45.212012f, 43.807361f, 59.863282f, 43.807361f, 43.807361f, 43.807361f, 0.000000f, 28.564424f }, // Level 146
{ 0.000000f, 60.256220f, 44.054826f, 44.054826f, 45.543749f, 44.054826f, 60.256220f, 44.054826f, 44.054826f, 44.054826f, 0.000000f, 28.746773f }, // Level 147
{ 0.000000f, 60.649157f, 44.302291f, 44.302291f, 45.875486f, 44.302291f, 60.649157f, 44.302291f, 44.302291f, 44.302291f, 0.000000f, 28.929122f }, // Level 148
{ 0.000000f, 61.042095f, 44.549757f, 44.549757f, 46.207223f, 44.549757f, 61.042095f, 44.549757f, 44.549757f, 44.549757f, 0.000000f, 29.111471f }, // Level 149
{ 0.000000f, 61.435033f, 44.797222f, 44.797222f, 46.538960f, 44.797222f, 61.435033f, 44.797222f, 44.797222f, 44.797222f, 0.000000f, 29.293820f }, // Level 150
{ 0.000000f, 61.827971f, 45.044687f, 45.044687f, 46.870697f, 45.044687f, 61.827971f, 45.044687f, 45.044687f, 45.044687f, 0.000000f, 29.476169f }, // Level 151
{ 0.000000f, 62.220909f, 45.292152f, 45.292152f, 47.202434f, 45.292152f, 62.220909f, 45.292152f, 45.292152f, 45.292152f, 0.000000f, 29.658518f }, // Level 152
{ 0.000000f, 62.613847f, 45.539618f, 45.539618f, 47.534171f, 45.539618f, 62.613847f, 45.539618f, 45.539618f, 45.539618f, 0.000000f, 29.840867f }, // Level 153
{ 0.000000f, 63.006785f, 45.787083f, 45.787083f, 47.865908f, 45.787083f, 63.006785f, 45.787083f, 45.787083f, 45.787083f, 0.000000f, 30.023216f }, // Level 154
{ 0.000000f, 63.399723f, 46.034548f, 46.034548f, 48.197645f, 46.034548f, 63.399723f, 46.034548f, 46.034548f, 46.034548f, 0.000000f, 30.205565f }, // Level 155
{ 0.000000f, 63.792661f, 46.282014f, 46.282014f, 48.529382f, 46.282014f, 63.792661f, 46.282014f, 46.282014f, 46.282014f, 0.000000f, 30.387914f }, // Level 156
{ 0.000000f, 64.185599f, 46.529479f, 46.529479f, 48.861119f, 46.529479f, 64.185599f, 46.529479f, 46.529479f, 46.529479f, 0.000000f, 30.570263f }, // Level 157
{ 0.000000f, 64.578537f, 46.776944f, 46.776944f, 49.192856f, 46.776944f, 64.578537f, 46.776944f, 46.776944f, 46.776944f, 0.000000f, 30.752612f }, // Level 158
{ 0.000000f, 64.971475f, 47.024409f, 47.024409f, 49.524593f, 47.024409f, 64.971475f, 47.024409f, 47.024409f, 47.024409f, 0.000000f, 30.934961f }, // Level 159
{ 0.000000f, 65.364413f, 47.271875f, 47.271875f, 49.856330f, 47.271875f, 65.364413f, 47.271875f, 47.271875f, 47.271875f, 0.000000f, 31.117310f }, // Level 160
{ 0.000000f, 65.757350f, 47.519340f, 47.519340f, 50.188067f, 47.519340f, 65.757350f, 47.519340f, 47.519340f, 47.519340f, 0.000000f, 31.299659f }, // Level 161
{ 0.000000f, 66.150288f, 47.766805f, 47.766805f, 50.519804f, 47.766805f, 66.150288f, 47.766805f, 47.766805f, 47.766805f, 0.000000f, 31.482008f }, // Level 162
{ 0.000000f, 66.543226f, 48.014271f, 48.014271f, 50.851541f, 48.014271f, 66.543226f, 48.014271f, 48.014271f, 48.014271f, 0.000000f, 31.664357f }, // Level 163
{ 0.000000f, 66.936164f, 48.261736f, 48.261736f, 51.183278f, 48.261736f, 66.936164f, 48.261736f, 48.261736f, 48.261736f, 0.000000f, 31.846706f }, // Level 164
{ 0.000000f, 67.329102f, 48.509201f, 48.509201f, 51.515015f, 48.509201f, 67.329102f, 48.509201f, 48.509201f, 48.509201f, 0.000000f, 32.029055f }, // Level 165
{ 0.000000f, 67.722040f, 48.756666f, 48.756666f, 51.846752f, 48.756666f, 67.722040f, 48.756666f, 48.756666f, 48.756666f, 0.000000f, 32.211404f }, // Level 166
{ 0.000000f, 68.114978f, 49.004132f, 49.004132f, 52.178489f, 49.004132f, 68.114978f, 49.004132f, 49.004132f, 49.004132f, 0.000000f, 32.393753f }, // Level 167
{ 0.000000f, 68.507916f, 49.251597f, 49.251597f, 52.510226f, 49.251597f, 68.507916f, 49.251597f, 49.251597f, 49.251597f, 0.000000f, 32.576102f }, // Level 168
{ 0.000000f, 68.900854f, 49.499062f, 49.499062f, 52.841963f, 49.499062f, 68.900854f, 49.499062f, 49.499062f, 49.499062f, 0.000000f, 32.758451f }, // Level 169
{ 0.000000f, 69.293792f, 49.746528f, 49.746528f, 53.173700f, 49.746528f, 69.293792f, 49.746528f, 49.746528f, 49.746528f, 0.000000f, 32.940800f }, // Level 170
{ 0.000000f, 69.686730f, 49.993993f, 49.993993f, 53.505437f, 49.993993f, 69.686730f, 49.993993f, 49.993993f, 49.993993f, 0.000000f, 33.123149f }, // Level 171
{ 0.000000f, 70.079668f, 50.241458f, 50.241458f, 53.837174f, 50.241458f, 70.079668f, 50.241458f, 50.241458f, 50.241458f, 0.000000f, 33.305498f }, // Level 172
{ 0.000000f, 70.472606f, 50.488923f, 50.488923f, 54.168911f, 50.488923f, 70.472606f, 50.488923f, 50.488923f, 50.488923f, 0.000000f, 33.487847f }, // Level 173
{ 0.000000f, 70.865543f, 50.736389f, 50.736389f, 54.500648f, 50.736389f, 70.865543f, 50.736389f, 50.736389f, 50.736389f, 0.000000f, 33.670196f }, // Level 174
{ 0.000000f, 71.258481f, 50.983854f, 50.983854f, 54.832385f, 50.983854f, 71.258481f, 50.983854f, 50.983854f, 50.983854f, 0.000000f, 33.852545f }, // Level 175
{ 0.000000f, 71.651419f, 51.231319f, 51.231319f, 55.164122f, 51.231319f, 71.651419f, 51.231319f, 51.231319f, 51.231319f, 0.000000f, 34.034894f }, // Level 176
{ 0.000000f, 72.044357f, 51.478784f, 51.478784f, 55.495859f, 51.478784f, 72.044357f, 51.478784f, 51.478784f, 51.478784f, 0.000000f, 34.217243f }, // Level 177
{ 0.000000f, 72.437295f, 51.726250f, 51.726250f, 55.827596f, 51.726250f, 72.437295f, 51.726250f, 51.726250f, 51.726250f, 0.000000f, 34.399592f }, // Level 178
{ 0.000000f, 72.830233f, 51.973715f, 51.973715f, 56.159333f, 51.973715f, 72.830233f, 51.973715f, 51.973715f, 51.973715f, 0.000000f, 34.581941f }, // Level 179
{ 0.000000f, 73.223171f, 52.221180f, 52.221180f, 56.491070f, 52.221180f, 73.223171f, 52.221180f, 52.221180f, 52.221180f, 0.000000f, 34.764290f }, // Level 180
{ 0.000000f, 73.616109f, 52.468646f, 52.468646f, 56.822807f, 52.468646f, 73.616109f, 52.468646f, 52.468646f, 52.468646f, 0.000000f, 34.946639f }, // Level 181
{ 0.000000f, 74.009047f, 52.716111f, 52.716111f, 57.154544f, 52.716111f, 74.009047f, 52.716111f, 52.716111f, 52.716111f, 0.000000f, 35.128988f }, // Level 182
{ 0.000000f, 74.401985f, 52.963576f, 52.963576f, 57.486281f, 52.963576f, 74.401985f, 52.963576f, 52.963576f, 52.963576f, 0.000000f, 35.311337f }, // Level 183
{ 0.000000f, 74.794923f, 53.211041f, 53.211041f, 57.818018f, 53.211041f, 74.794923f, 53.211041f, 53.211041f, 53.211041f, 0.000000f, 35.493686f }, // Level 184
{ 0.000000f, 75.187861f, 53.458507f, 53.458507f, 58.149755f, 53.458507f, 75.187861f, 53.458507f, 53.458507f, 53.458507f, 0.000000f, 35.676035f }, // Level 185
{ 0.000000f, 75.580799f, 53.705972f, 53.705972f, 58.481492f, 53.705972f, 75.580799f, 53.705972f, 53.705972f, 53.705972f, 0.000000f, 35.858384f }, // Level 186
{ 0.000000f, 75.973736f, 53.953437f, 53.953437f, 58.813229f, 53.953437f, 75.973736f, 53.953437f, 53.953437f, 53.953437f, 0.000000f, 36.040733f }, // Level 187
{ 0.000000f, 76.366674f, 54.200903f, 54.200903f, 59.144966f, 54.200903f, 76.366674f, 54.200903f, 54.200903f, 54.200903f, 0.000000f, 36.223082f }, // Level 188
{ 0.000000f, 76.759612f, 54.448368f, 54.448368f, 59.476703f, 54.448368f, 76.759612f, 54.448368f, 54.448368f, 54.448368f, 0.000000f, 36.405431f }, // Level 189
{ 0.000000f, 77.152550f, 54.695833f, 54.695833f, 59.808440f, 54.695833f, 77.152550f, 54.695833f, 54.695833f, 54.695833f, 0.000000f, 36.587780f }, // Level 190
{ 0.000000f, 77.545488f, 54.943298f, 54.943298f, 60.140177f, 54.943298f, 77.545488f, 54.943298f, 54.943298f, 54.943298f, 0.000000f, 36.770129f }, // Level 191
{ 0.000000f, 77.938426f, 55.190764f, 55.190764f, 60.471914f, 55.190764f, 77.938426f, 55.190764f, 55.190764f, 55.190764f, 0.000000f, 36.952478f }, // Level 192
{ 0.000000f, 78.331364f, 55.438229f, 55.438229f, 60.803651f, 55.438229f, 78.331364f, 55.438229f, 55.438229f, 55.438229f, 0.000000f, 37.134827f }, // Level 193
{ 0.000000f, 78.724302f, 55.685694f, 55.685694f, 61.135388f, 55.685694f, 78.724302f, 55.685694f, 55.685694f, 55.685694f, 0.000000f, 37.317176f }, // Level 194
{ 0.000000f, 79.117240f, 55.933160f, 55.933160f, 61.467125f, 55.933160f, 79.117240f, 55.933160f, 55.933160f, 55.933160f, 0.000000f, 37.499525f }, // Level 195
{ 0.000000f, 79.510178f, 56.180625f, 56.180625f, 61.798862f, 56.180625f, 79.510178f, 56.180625f, 56.180625f, 56.180625f, 0.000000f, 37.681874f }, // Level 196
{ 0.000000f, 79.903116f, 56.428090f, 56.428090f, 62.130599f, 56.428090f, 79.903116f, 56.428090f, 56.428090f, 56.428090f, 0.000000f, 37.864223f }, // Level 197
{ 0.000000f, 80.296054f, 56.675555f, 56.675555f, 62.462336f, 56.675555f, 80.296054f, 56.675555f, 56.675555f, 56.675555f, 0.000000f, 38.046572f }, // Level 198
{ 0.000000f, 80.688992f, 56.923021f, 56.923021f, 62.794073f, 56.923021f, 80.688992f, 56.923021f, 56.923021f, 56.923021f, 0.000000f, 38.228921f }, // Level 199
{ 0.000000f, 81.081929f, 57.170486f, 57.170486f, 63.125810f, 57.170486f, 81.081929f, 57.170486f, 57.170486f, 57.170486f, 0.000000f, 38.411270f }, // Level 200
{ 0.000000f, 81.474867f, 57.417951f, 57.417951f, 63.457547f, 57.417951f, 81.474867f, 57.417951f, 57.417951f, 57.417951f, 0.000000f, 38.593619f }, // Level 201
{ 0.000000f, 81.867805f, 57.665416f, 57.665416f, 63.789284f, 57.665416f, 81.867805f, 57.665416f, 57.665416f, 57.665416f, 0.000000f, 38.775968f }, // Level 202
{ 0.000000f, 82.260743f, 57.912882f, 57.912882f, 64.121021f, 57.912882f, 82.260743f, 57.912882f, 57.912882f, 57.912882f, 0.000000f, 38.958317f }, // Level 203
{ 0.000000f, 82.653681f, 58.160347f, 58.160347f, 64.452758f, 58.160347f, 82.653681f, 58.160347f, 58.160347f, 58.160347f, 0.000000f, 39.140666f }, // Level 204
{ 0.000000f, 83.046619f, 58.407812f, 58.407812f, 64.784495f, 58.407812f, 83.046619f, 58.407812f, 58.407812f, 58.407812f, 0.000000f, 39.323015f }, // Level 205
{ 0.000000f, 83.439557f, 58.655278f, 58.655278f, 65.116232f, 58.655278f, 83.439557f, 58.655278f, 58.655278f, 58.655278f, 0.000000f, 39.505364f }, // Level 206
{ 0.000000f, 83.832495f, 58.902743f, 58.902743f, 65.447969f, 58.902743f, 83.832495f, 58.902743f, 58.902743f, 58.902743f, 0.000000f, 39.687713f }, // Level 207
{ 0.000000f, 84.225433f, 59.150208f, 59.150208f, 65.779706f, 59.150208f, 84.225433f, 59.150208f, 59.150208f, 59.150208f, 0.000000f, 39.870062f }, // Level 208
{ 0.000000f, 84.618371f, 59.397673f, 59.397673f, 66.111443f, 59.397673f, 84.618371f, 59.397673f, 59.397673f, 59.397673f, 0.000000f, 40.052411f }, // Level 209
{ 0.000000f, 85.011309f, 59.645139f, 59.645139f, 66.443180f, 59.645139f, 85.011309f, 59.645139f, 59.645139f, 59.645139f, 0.000000f, 40.234760f }, // Level 210
{ 0.000000f, 85.404247f, 59.892604f, 59.892604f, 66.774917f, 59.892604f, 85.404247f, 59.892604f, 59.892604f, 59.892604f, 0.000000f, 40.417109f }, // Level 211
{ 0.000000f, 85.797185f, 60.140069f, 60.140069f, 67.106654f, 60.140069f, 85.797185f, 60.140069f, 60.140069f, 60.140069f, 0.000000f, 40.599458f }, // Level 212
{ 0.000000f, 86.190122f, 60.387535f, 60.387535f, 67.438391f, 60.387535f, 86.190122f, 60.387535f, 60.387535f, 60.387535f, 0.000000f, 40.781807f }, // Level 213
{ 0.000000f, 86.583060f, 60.635000f, 60.635000f, 67.770128f, 60.635000f, 86.583060f, 60.635000f, 60.635000f, 60.635000f, 0.000000f, 40.964156f }, // Level 214
{ 0.000000f, 86.975998f, 60.882465f, 60.882465f, 68.101865f, 60.882465f, 86.975998f, 60.882465f, 60.882465f, 60.882465f, 0.000000f, 41.146505f }, // Level 215
{ 0.000000f, 87.368936f, 61.129930f, 61.129930f, 68.433602f, 61.129930f, 87.368936f, 61.129930f, 61.129930f, 61.129930f, 0.000000f, 41.328854f }, // Level 216
{ 0.000000f, 87.761874f, 61.377396f, 61.377396f, 68.765339f, 61.377396f, 87.761874f, 61.377396f, 61.377396f, 61.377396f, 0.000000f, 41.511203f }, // Level 217
{ 0.000000f, 88.154812f, 61.624861f, 61.624861f, 69.097076f, 61.624861f, 88.154812f, 61.624861f, 61.624861f, 61.624861f, 0.000000f, 41.693552f }, // Level 218
{ 0.000000f, 88.547750f, 61.872326f, 61.872326f, 69.428813f, 61.872326f, 88.547750f, 61.872326f, 61.872326f, 61.872326f, 0.000000f, 41.875901f }, // Level 219
{ 0.000000f, 88.940688f, 62.119792f, 62.119792f, 69.760550f, 62.119792f, 88.940688f, 62.119792f, 62.119792f, 62.119792f, 0.000000f, 42.058250f }, // Level 220
{ 0.000000f, 89.333626f, 62.367257f, 62.367257f, 70.092287f, 62.367257f, 89.333626f, 62.367257f, 62.367257f, 62.367257f, 0.000000f, 42.240599f }, // Level 221
{ 0.000000f, 89.726564f, 62.614722f, 62.614722f, 70.424024f, 62.614722f, 89.726564f, 62.614722f, 62.614722f, 62.614722f, 0.000000f, 42.422948f }, // Level 222
{ 0.000000f, 90.119502f, 62.862187f, 62.862187f, 70.755761f, 62.862187f, 90.119502f, 62.862187f, 62.862187f, 62.862187f, 0.000000f, 42.605297f }, // Level 223
{ 0.000000f, 90.512440f, 63.109653f, 63.109653f, 71.087498f, 63.109653f, 90.512440f, 63.109653f, 63.109653f, 63.109653f, 0.000000f, 42.787646f }, // Level 224
{ 0.000000f, 90.905378f, 63.357118f, 63.357118f, 71.419235f, 63.357118f, 90.905378f, 63.357118f, 63.357118f, 63.357118f, 0.000000f, 42.969995f }, // Level 225
{ 0.000000f, 91.298315f, 63.604583f, 63.604583f, 71.750972f, 63.604583f, 91.298315f, 63.604583f, 63.604583f, 63.604583f, 0.000000f, 43.152344f }, // Level 226
{ 0.000000f, 91.691253f, 63.852048f, 63.852048f, 72.082709f, 63.852048f, 91.691253f, 63.852048f, 63.852048f, 63.852048f, 0.000000f, 43.334693f }, // Level 227
{ 0.000000f, 92.084191f, 64.099514f, 64.099514f, 72.414446f, 64.099514f, 92.084191f, 64.099514f, 64.099514f, 64.099514f, 0.000000f, 43.517042f }, // Level 228
{ 0.000000f, 92.477129f, 64.346979f, 64.346979f, 72.746183f, 64.346979f, 92.477129f, 64.346979f, 64.346979f, 64.346979f, 0.000000f, 43.699391f }, // Level 229
{ 0.000000f, 92.870067f, 64.594444f, 64.594444f, 73.077920f, 64.594444f, 92.870067f, 64.594444f, 64.594444f, 64.594444f, 0.000000f, 43.881740f }, // Level 230
{ 0.000000f, 93.263005f, 64.841910f, 64.841910f, 73.409657f, 64.841910f, 93.263005f, 64.841910f, 64.841910f, 64.841910f, 0.000000f, 44.064089f }, // Level 231
{ 0.000000f, 93.655943f, 65.089375f, 65.089375f, 73.741394f, 65.089375f, 93.655943f, 65.089375f, 65.089375f, 65.089375f, 0.000000f, 44.246438f }, // Level 232
{ 0.000000f, 94.048881f, 65.336840f, 65.336840f, 74.073131f, 65.336840f, 94.048881f, 65.336840f, 65.336840f, 65.336840f, 0.000000f, 44.428787f }, // Level 233
{ 0.000000f, 94.441819f, 65.584305f, 65.584305f, 74.404868f, 65.584305f, 94.441819f, 65.584305f, 65.584305f, 65.584305f, 0.000000f, 44.611136f }, // Level 234
{ 0.000000f, 94.834757f, 65.831771f, 65.831771f, 74.736605f, 65.831771f, 94.834757f, 65.831771f, 65.831771f, 65.831771f, 0.000000f, 44.793485f }, // Level 235
{ 0.000000f, 95.227695f, 66.079236f, 66.079236f, 75.068342f, 66.079236f, 95.227695f, 66.079236f, 66.079236f, 66.079236f, 0.000000f, 44.975834f }, // Level 236
{ 0.000000f, 95.620633f, 66.326701f, 66.326701f, 75.400079f, 66.326701f, 95.620633f, 66.326701f, 66.326701f, 66.326701f, 0.000000f, 45.158183f }, // Level 237
{ 0.000000f, 96.013571f, 66.574167f, 66.574167f, 75.731816f, 66.574167f, 96.013571f, 66.574167f, 66.574167f, 66.574167f, 0.000000f, 45.340532f }, // Level 238
{ 0.000000f, 96.406508f, 66.821632f, 66.821632f, 76.063553f, 66.821632f, 96.406508f, 66.821632f, 66.821632f, 66.821632f, 0.000000f, 45.522881f }, // Level 239
{ 0.000000f, 96.799446f, 67.069097f, 67.069097f, 76.395290f, 67.069097f, 96.799446f, 67.069097f, 67.069097f, 67.069097f, 0.000000f, 45.705230f }, // Level 240
{ 0.000000f, 97.192384f, 67.316562f, 67.316562f, 76.727027f, 67.316562f, 97.192384f, 67.316562f, 67.316562f, 67.316562f, 0.000000f, 45.887579f }, // Level 241
{ 0.000000f, 97.585322f, 67.564028f, 67.564028f, 77.058764f, 67.564028f, 97.585322f, 67.564028f, 67.564028f, 67.564028f, 0.000000f, 46.069928f }, // Level 242
{ 0.000000f, 97.978260f, 67.811493f, 67.811493f, 77.390501f, 67.811493f, 97.978260f, 67.811493f, 67.811493f, 67.811493f, 0.000000f, 46.252277f }, // Level 243
{ 0.000000f, 98.371198f, 68.058958f, 68.058958f, 77.722238f, 68.058958f, 98.371198f, 68.058958f, 68.058958f, 68.058958f, 0.000000f, 46.434626f }, // Level 244
{ 0.000000f, 98.764136f, 68.306424f, 68.306424f, 78.053975f, 68.306424f, 98.764136f, 68.306424f, 68.306424f, 68.306424f, 0.000000f, 46.616975f }, // Level 245
{ 0.000000f, 99.157074f, 68.553889f, 68.553889f, 78.385712f, 68.553889f, 99.157074f, 68.553889f, 68.553889f, 68.553889f, 0.000000f, 46.799324f }, // Level 246
{ 0.000000f, 99.550012f, 68.801354f, 68.801354f, 78.717449f, 68.801354f, 99.550012f, 68.801354f, 68.801354f, 68.801354f, 0.000000f, 46.981673f }, // Level 247
{ 0.000000f, 99.942950f, 69.048819f, 69.048819f, 79.049186f, 69.048819f, 99.942950f, 69.048819f, 69.048819f, 69.048819f, 0.000000f, 47.164022f }, // Level 248
{ 0.000000f, 100.33588f, 69.296285f, 69.296285f, 79.380923f, 69.296285f, 100.33588f, 69.296285f, 69.296285f, 69.296285f, 0.000000f, 47.346371f }, // Level 249
{ 0.000000f, 100.72882f, 69.543750f, 69.543750f, 79.712660f, 69.543750f, 100.72882f, 69.543750f , 69.543750f, 69.543750f, 0.000000f, 47.52872f } // Level 250
};
/*
Exalted	        1,000	 Access to racial mounts. Capped at 999.7
Revered	        21,000	 Heroic mode keys for Outland dungeons
Honored	        12,000	 10% discount from faction vendors
Friendly	    6,000
Neutral	        3,000
Unfriendly	    3,000	 Cannot buy, sell or interact.
Hostile	        3,000	 You will always be attacked on sight
Hated	        36,000 
*/
static const uint8 baseRunes[6] = {RUNE_TYPE_BLOOD,RUNE_TYPE_BLOOD,RUNE_TYPE_FROST,RUNE_TYPE_FROST,RUNE_TYPE_UNHOLY,RUNE_TYPE_UNHOLY};

enum FactionRating
{
	HATED,
	HOSTILE,
	UNFRIENDLY,
	NEUTRAL,
	FRIENDLY,
	HONORED,
	REVERED,
	EXALTED
};

struct FactionReputation
{
	int32 standing;
	uint8 flag;
	int32 baseStanding;
	ASCENT_INLINE int32 CalcStanding() { return standing - baseStanding; }
	ASCENT_INLINE bool Positive() { return standing >= 0; }
};

struct PlayerInfo
{
	~PlayerInfo();
	uint32 guid;
	uint32 acct;
	char * name;
	uint32 race;
	uint32 gender;
	uint32 cl;
	uint32 team;
	
	time_t lastOnline;
	uint32 lastZone;
	uint32 lastLevel;
	Group * m_Group;
	int8 subGroup;
#ifdef VOICE_CHAT
	int8 groupVoiceId;
#endif

	Player * m_loggedInPlayer;
	Guild * guild;
	GuildRank * guildRank;
	GuildMember * guildMember;
	ArenaTeam * arenaTeam[NUM_ARENA_TEAM_TYPES];
	uint32 charterId[NUM_CHARTER_TYPES];
};
struct PlayerPet
{
	uint32 number;
	string name;
	uint32 entry;
	string fields;
	uint32 xp;
	bool active;
	uint32 level;	
	uint32 loyaltypts;
	uint32 loyaltylvl; 
	uint32 happinessupdate;
	bool   summon;

	char stablestate;
	string actionbar;
	uint32 actionbarspell[10];
	uint32 actionbarspellstate[10];
};

enum MeetingStoneQueueStatus
{
	MEETINGSTONE_STATUS_NONE								= 0,
	MEETINGSTONE_STATUS_JOINED_MEETINGSTONE_QUEUE_FOR	   = 1,
	MEETINGSTONE_STATUS_PARTY_MEMBER_LEFT_LFG			   = 2,
	MEETINGSTONE_STATUS_PARTY_MEMBER_REMOVED_PARTY_REMOVED  = 3,
	MEETINGSTONE_STATUS_LOOKING_FOR_NEW_PARTY_IN_QUEUE	  = 4,
	MEETINGSTONE_STATUS_NONE_UNK							= 5,
};
enum ItemPushResultTypes
{
	ITEM_PUSH_TYPE_LOOT			 = 0x00000000,
	ITEM_PUSH_TYPE_RECEIVE		  = 0x00000001,
	ITEM_PUSH_TYPE_CREATE		   = 0x00000002,
};
struct WeaponModifier
{
	uint32 wclass;
	uint32 subclass;
	float value;
};
struct PetActionBar
{
	uint32 spell[10];
};
struct classScriptOverride
{
	uint32 id;
	uint32 effect;
	uint32 aura;
	uint32 damage;
	bool percent;
};
class Spell;
class Item;
class Container;
class WorldSession;
class ItemInterface;
class GossipMenu;
class AchievementInterface;
struct TaxiPathNode;

#define RESTSTATE_RESTED			 1
#define RESTSTATE_NORMAL			 2
#define RESTSTATE_TIRED100		     3
#define RESTSTATE_TIRED50			 4
#define RESTSTATE_EXHAUSTED		     5

#define UNDERWATERSTATE_NONE		 0x00000000
#define UNDERWATERSTATE_SWIMMING	 0x00000001
#define UNDERWATERSTATE_UNDERWATER   0x00000002
#define UNDERWATERSTATE_RECOVERING   0x00000004
#define UNDERWATERSTATE_TAKINGDAMAGE 0x00000008
#define UNDERWATERSTATE_FATIGUE	     0x00000010
#define UNDERWATERSTATE_LAVA		 0x00000020
#define UNDERWATERSTATE_SLIME		 0x00000040

enum TRADE_STATUS
{
	TRADE_STATUS_PLAYER_BUSY	    = 0x00,
	TRADE_STATUS_PROPOSED		    = 0x01,
	TRADE_STATUS_INITIATED		    = 0x02,
	TRADE_STATUS_CANCELLED		    = 0x03,
	TRADE_STATUS_ACCEPTED		    = 0x04,
	TRADE_STATUS_ALREADY_TRADING    = 0x05,
	TRADE_STATUS_PLAYER_NOT_FOUND   = 0x06,
	TRADE_STATUS_STATE_CHANGED	    = 0x07,
	TRADE_STATUS_COMPLETE		    = 0x08,
	TRADE_STATUS_UNACCEPTED		    = 0x09,
	TRADE_STATUS_TOO_FAR_AWAY	    = 0x0A,
	TRADE_STATUS_WRONG_FACTION	    = 0x0B,
	TRADE_STATUS_FAILED			    = 0x0C,
	TRADE_STATUS_DEAD			    = 0x0D,
	TRADE_STATUS_PLAYER_IGNORED	    = 0x0E,
	TRADE_STATUS_YOU_STUNNED		= 0x0F,
	TRADE_STATUS_TARGET_STUNNED		= 0x10,
	TRADE_STATUS_UNK				= 0x11,
	TRADE_STATUS_TARGET_DEAD		= 0x12,
	TRADE_STATUS_YOU_LOGOUT			= 0x13,
	TRADE_STATUS_TARGET_LOGOUT		= 0x14,
	TRADE_STATUS_TRIAL_ACCOUNT		= 0x15,
	TRADE_STATUS_ONLY_CONJURED		= 0x16,
};
enum TRADE_DATA
{
	TRADE_GIVE		= 0x00,
	TRADE_RECEIVE	 = 0x01,
};
enum DUEL_STATUS
{
	DUEL_STATUS_OUTOFBOUNDS,
	DUEL_STATUS_INBOUNDS
};
enum DUEL_STATE
{
	DUEL_STATE_REQUESTED,
	DUEL_STATE_STARTED,
	DUEL_STATE_FINISHED
};
enum DUEL_WINNER
{
	DUEL_WINNER_KNOCKOUT,
	DUEL_WINNER_RETREAT,
};
#define PLAYER_ATTACK_TIMEOUT_INTERVAL	5000
#define PLAYER_FORCED_RESURECT_INTERVAL	360000 // 1000*60*6= 6 minutes 

struct PlayerSkill
{
	skilllineentry * Skill;
	uint32 CurrentValue;
	uint32 MaximumValue;
	uint32 BonusValue;
	float GetSkillUpChance();
	void Reset(uint32 Id);
};

enum SPELL_INDEX
{
	SPELL_TYPE_INDEX_MARK			= 1,
	SPELL_TYPE_INDEX_POLYMORPH		= 2,
	SPELL_TYPE_INDEX_FEAR			= 3,
	SPELL_TYPE_INDEX_SAP			= 4,
	SPELL_TYPE_INDEX_SCARE_BEAST	= 5,
	SPELL_TYPE_INDEX_HIBERNATE		= 6,
	SPELL_TYPE_INDEX_EARTH_SHIELD	= 7,
	SPELL_TYPE_INDEX_CYCLONE		= 8,
	SPELL_TYPE_INDEX_BANISH			= 9,
	SPELL_TYPE_INDEX_JUDGEMENT		= 10,	
	SPELL_TYPE_INDEX_REPENTANCE		= 11,
	SPELL_TYPE_INDEX_SLOW			= 12,
	NUM_SPELL_TYPE_INDEX			= 13,
};

#define PLAYER_RATING_MODIFIER_RANGED_SKILL						PLAYER_FIELD_COMBAT_RATING_1
#define PLAYER_RATING_MODIFIER_DEFENCE							PLAYER_FIELD_COMBAT_RATING_1_1
#define PLAYER_RATING_MODIFIER_DODGE							PLAYER_FIELD_COMBAT_RATING_1_2
#define PLAYER_RATING_MODIFIER_PARRY							PLAYER_FIELD_COMBAT_RATING_1_3
#define PLAYER_RATING_MODIFIER_BLOCK							PLAYER_FIELD_COMBAT_RATING_1_4
#define PLAYER_RATING_MODIFIER_MELEE_HIT						PLAYER_FIELD_COMBAT_RATING_1_5
#define PLAYER_RATING_MODIFIER_RANGED_HIT						PLAYER_FIELD_COMBAT_RATING_1_6
#define PLAYER_RATING_MODIFIER_SPELL_HIT						PLAYER_FIELD_COMBAT_RATING_1_7
#define PLAYER_RATING_MODIFIER_MELEE_CRIT						PLAYER_FIELD_COMBAT_RATING_1_8
#define PLAYER_RATING_MODIFIER_RANGED_CRIT						PLAYER_FIELD_COMBAT_RATING_1_9
#define PLAYER_RATING_MODIFIER_SPELL_CRIT						PLAYER_FIELD_COMBAT_RATING_1_10
#define PLAYER_RATING_MODIFIER_MELEE_HIT_AVOIDANCE				PLAYER_FIELD_COMBAT_RATING_1_11 // GUESSED
#define PLAYER_RATING_MODIFIER_RANGED_HIT_AVOIDANCE				PLAYER_FIELD_COMBAT_RATING_1_12 // GUESSED
#define PLAYER_RATING_MODIFIER_SPELL_HIT_AVOIDANCE				PLAYER_FIELD_COMBAT_RATING_1_13 // GUESSED
#define PLAYER_RATING_MODIFIER_MELEE_CRIT_RESILIENCE			PLAYER_FIELD_COMBAT_RATING_1_14
#define PLAYER_RATING_MODIFIER_RANGED_CRIT_RESILIENCE			PLAYER_FIELD_COMBAT_RATING_1_15
#define PLAYER_RATING_MODIFIER_SPELL_CRIT_RESILIENCE			PLAYER_FIELD_COMBAT_RATING_1_16
#define PLAYER_RATING_MODIFIER_MELEE_HASTE						PLAYER_FIELD_COMBAT_RATING_1_17
#define PLAYER_RATING_MODIFIER_RANGED_HASTE						PLAYER_FIELD_COMBAT_RATING_1_18
#define PLAYER_RATING_MODIFIER_SPELL_HASTE						PLAYER_FIELD_COMBAT_RATING_1_19
#define PLAYER_RATING_MODIFIER_MELEE_MAIN_HAND_SKILL			PLAYER_FIELD_COMBAT_RATING_1_20
#define PLAYER_RATING_MODIFIER_MELEE_OFF_HAND_SKILL				PLAYER_FIELD_COMBAT_RATING_1_21
#define PLAYER_RATING_MODIFIER_HIT_AVOIDANCE_RATING				PLAYER_FIELD_COMBAT_RATING_1_22
#define PLAYER_RATING_MODIFIER_EXPERTISE						PLAYER_FIELD_COMBAT_RATING_1_23
#define PLAYER_RATING_MODIFIER_ARMOR_PENETRATION_RATING			PLAYER_FIELD_COMBAT_RATING_1_24 //Added in 3.0.2

class ArenaTeam;
struct PlayerCooldown
{
	uint32 ExpireTime;
	uint32 ItemId;
	uint32 SpellId;
};

//====================================================================
//  Player
//  Class that holds every created character on the server.
//
//  TODO:  Attach characters to user accounts
//====================================================================
typedef std::set<uint32>	                        SpellSet;
typedef std::list<classScriptOverride*>             ScriptOverrideList;
typedef std::set<uint32>                            SaveSet;
typedef std::map<uint64, ByteBuffer*>               SplineMap;
typedef std::map<uint32, ScriptOverrideList* >      SpellOverrideMap;
typedef std::map<uint32, uint32>                    SpellOverrideExtraAuraMap;
typedef std::map<uint32, FactionReputation*>        ReputationMap;
typedef std::map<uint32, uint64>                    SoloSpells;
typedef std::map<SpellEntry*, pair<uint32, uint32> >StrikeSpellMap;
typedef std::map<uint32, OnHitSpell >               StrikeSpellDmgMap;
typedef std::map<uint32, PlayerSkill>				SkillMap;
typedef std::set<Player**>							ReferenceSet;
typedef std::map<uint32, PlayerCooldown>			PlayerCooldownMap;

//#define OPTIMIZED_PLAYER_SAVING

class SERVER_DECL Player : public Unit
{
	friend class WorldSession;
	friend class Pet;
	friend class SkillIterator;

public:

	Player ( uint32 guid );
	~Player();
	virtual void Destructor();
	virtual void Init();

	void UpdateKnownGlyphs();

	const char* GetObjectName();
	virtual void OnPositionChange(); 

	ASCENT_INLINE bool CanUseGlyphSlot(uint8 slot) { return (slot < 6 && GetUInt32Value(PLAYER_GLYPHS_ENABLED) & (1 << slot)); }

	/*std::multimap<uint32, uint32> m_areaidauras;
	std::multimap<uint32, uint32> m_zoneidauras;*/

	//RuneSlot m_runes[RUNE_SLOTS];
	uint8 m_runes[RUNE_SLOTS];
	uint8 m_runemask;
	uint32 m_timesync;

	uint8 GetRune(uint32 index)
	{
		return m_runes[index];
	}
	uint8 GetBaseRune(uint8 index)
	{
		return baseRunes[index];
	}
	void SetRune(uint8 index, uint8 value)
	{
		m_runes[index] = value;
	}

	void ScheduleRuneRefresh(uint8 index, bool forceDeathRune = false);

	bool CanUseRunes(uint8 RuneBlood, uint8 RuneFrost, uint8 RuneUnholy);
	void UseRunes(uint8 RuneBlood, uint8 RuneFrost, uint8 RuneUnholy, SpellEntry * pSpell = NULL);
	uint8 TheoreticalUseRunes(uint8 RuneBlood, uint8 RuneFrost, uint8 RuneUnholy);
	void ClearRuneCooldown(uint8 index);

	uint32 m_deathRuneMasteryChance;
	
	ASCENT_INLINE void RuneRefresh(uint8 slot)
	{
		m_runemask |= (1 << slot);
	}

	ASCENT_INLINE void ConvertRune(uint8 slot, uint8 type)
	{
	ASSERT(slot < 6);
	m_runes[slot] = type;
	m_runemask |= (1 << slot);
	if(type >= RUNE_TYPE_RECHARGING)
		return;

	WorldPacket data(SMSG_CONVERT_RUNE, 2);
	data << (uint8)slot;
	data << (uint8)type;
	if( GetSession() )
		GetSession()->SendPacket(&data);

	/*m_runes[slot].runeType = type;
	WorldPacket data(SMSG_CONVERT_RUNE, 2);
	data << slot << type;
	if (GetSession() != NULL)
		GetSession()->SendPacket(&data);*/
	}

	ASCENT_INLINE Guild * GetGuild() { return m_playerInfo->guild; }
	ASCENT_INLINE GuildMember * GetGuildMember() { return m_playerInfo->guildMember; }
	ASCENT_INLINE GuildRank * GetGuildRankS() { return m_playerInfo->guildRank; }

	void EventGroupFullUpdate();
    void GroupUninvite(Player *player, PlayerInfo *info);
	/************************************************************************/
	/* Skill System															*/
	/************************************************************************/

	void _AdvanceSkillLine(uint32 SkillLine, uint32 Count = 1);
	void _AddSkillLine(uint32 SkillLine, uint32 Current, uint32 Max);
	uint32 _GetSkillLineMax(uint32 SkillLine);
	uint32 _GetSkillLineCurrent(uint32 SkillLine, bool IncludeBonus = true);
	void _RemoveSkillLine(uint32 SkillLine);
	void _UpdateMaxSkillCounts();
	void _ModifySkillBonus(uint32 SkillLine, int32 Delta);
	void _ModifySkillBonusByType(uint32 SkillType, int32 Delta);
	bool _HasSkillLine(uint32 SkillLine);
	void RemoveSpellsFromLine(uint32 skill_line);
	void _RemoveAllSkills();
	void _RemoveLanguages();
	void _AddLanguages(bool All);
	void _AdvanceAllSkills(uint32 count);
	void _ModifySkillMaximum(uint32 SkillLine, uint32 NewMax);


	void RecalculateHonor();

	LfgMatch * m_lfgMatch;
	uint32 m_lfgInviterGuid;

	void EventTimeoutLfgInviter();

protected:

	void _UpdateSkillFields();

	SkillMap m_skills;


	// COOLDOWNS
	PlayerCooldownMap m_cooldownMap[NUM_COOLDOWN_TYPES];
	uint32 m_globalCooldown;
	
public:
	void Cooldown_OnCancel(SpellEntry *pSpell);
	void Cooldown_AddStart(SpellEntry * pSpell);
	void Cooldown_Add(SpellEntry * pSpell, Item * pItemCaster);
	void Cooldown_AddItem(ItemPrototype * pProto, uint32 x);
	bool Cooldown_CanCast(SpellEntry * pSpell);
	bool Cooldown_CanCast(ItemPrototype * pProto, uint32 x);

protected:
	void _Cooldown_Add(uint32 Type, uint32 Misc, uint32 Time, uint32 SpellId, uint32 ItemId);
	void _LoadPlayerCooldowns(QueryResult * result);
	void _SavePlayerCooldowns(QueryBuffer * buf);

	// END COOLDOWNS

public:

	bool ok_to_remove;
	uint64 m_spellIndexTypeTargets[NUM_SPELL_TYPE_INDEX];
	void OnLogin();//custom stuff on player login.
	void EquipInit(PlayerCreateInfo *EquipInfo);
	void RemoveSpellTargets(uint32 Type);
	void RemoveSpellIndexReferences(uint32 Type);
	void SetSpellTargetType(uint32 Type, Unit* target);
	void SendMeetingStoneQueue(uint32 DungeonId, uint8 Status);

	void AddToWorld();
	void AddToWorld(MapMgr * pMapMgr);
	void RemoveFromWorld();
	bool Create ( WorldPacket &data );
	
	void Update( uint32 time );
	//void BuildEnumData( WorldPacket * p_data );
    void BuildFlagUpdateForNonGroupSet(uint32 index, uint32 flag);
	std::string m_afk_reason;
	void SetAFKReason(std::string reason) { m_afk_reason = reason; };
	ASCENT_INLINE const char *GetName() { return m_name.c_str(); }
	ASCENT_INLINE std::string *GetNameString() { return &m_name; }

    void SetClassString(void) 
	{
	 uint8 PlayerClass = GetByte( UNIT_FIELD_BYTES_0, 1); // class Player
	 
	 switch(PlayerClass)
	 {
	  case WARRIOR     : m_ClassName = "Guerrier"; break;  // 1
	  case PALADIN     : m_ClassName = "Paladin";  break;  // 2
	  case HUNTER      : m_ClassName = "Chasseur"; break; // 3
	  case ROGUE       : m_ClassName = "Voleur";   break;  // 4
	  case PRIEST      : m_ClassName = "Homme de priere"; break; // 5
	  case DEATHKNIGHT : m_ClassName = "Chevalier"; break; // 6
	  case SHAMAN      : m_ClassName = "Shaman";    break; // 7
	  case MAGE        : m_ClassName = "Sorcier";   break; // 8
	  case WARLOCK     : m_ClassName = "Demoniste"; break; // 9
	  case DRUID       : m_ClassName = "Druide";    break;  // 11 
	  case UNK_CLASS1  : // 0
	  case UNK_CLASS2  : // 10
	  default          : m_ClassName = "Inconnu"; break; // 11 
	 }
	}
	ASCENT_INLINE const char *GetClassPlayer() { return m_ClassName.c_str(); }
	ASCENT_INLINE std::string *GetClassPlayerString() { return &m_ClassName; }

	void Die();
	//void KilledMonster(uint32 entry, const uint64 &guid);
	void GiveXP(uint32 xp, const uint64 &guid, bool allowbonus);   // to stop rest xp being given
	//void ModifyBonuses(uint32 type,int32 val);
	std::map<uint32, uint32> m_wratings;

	ArenaTeam * m_arenaTeams[NUM_ARENA_TEAM_TYPES];
	
    /************************************************************************/
    /* Taxi                                                                 */
    /************************************************************************/
    ASCENT_INLINE TaxiPath*    GetTaxiPath() { return m_CurrentTaxiPath; }
    ASCENT_INLINE bool         GetTaxiState() { return m_onTaxi; }
    const uint32&       GetTaximask( uint8 index ) const { return m_taximask[index]; }
    void                LoadTaxiMask(const char* data);
    void                TaxiStart(TaxiPath* path, uint32 modelid, uint32 start_node);
    void                JumpToEndTaxiNode(TaxiPath * path);
    void                EventDismount(uint32 money, float x, float y, float z);
    void                EventTaxiDismount(TaxiPathNode* pn);
    void                EventTaxiInterpolate();

    ASCENT_INLINE void         SetTaxiState    (bool state) { m_onTaxi = state; }
    ASCENT_INLINE void         SetTaximask     (uint8 index, uint32 value ) { m_taximask[index] = value; }
    ASCENT_INLINE void         SetTaxiPath     (TaxiPath *path) { m_CurrentTaxiPath = path; }
    ASCENT_INLINE void         SetTaxiPos()	{m_taxi_pos_x = m_position.x; m_taxi_pos_y = m_position.y; m_taxi_pos_z = m_position.z;}
    ASCENT_INLINE void         UnSetTaxiPos()	{m_taxi_pos_x = 0; m_taxi_pos_y = 0; m_taxi_pos_z = 0; }
 
	// Taxi related variables
	vector<TaxiPath*>   m_taxiPaths;
    TaxiPath*           m_CurrentTaxiPath;
    uint32              taxi_model_id;
	uint32              lastNode;
    uint32              m_taxi_ride_time;
    uint32              m_taximask[NUM_TAXI_FIELDS];
    float               m_taxi_pos_x;
    float               m_taxi_pos_y;
    float               m_taxi_pos_z;
    bool                m_onTaxi;
	uint32				m_taxiMapChangeNode;

    /************************************************************************/
    /* Quests                                                               */
    /************************************************************************/
	bool HasQuests() 
	{
		for(int i = 0; i < 25; ++i)
		{
			if(m_questlog[i] != 0)
				return true;
		}
		return false;
	}
	
	void WipeDailyQuests();
	int32                GetOpenQuestSlot();
	QuestLogEntry*       GetQuestLogForEntry(uint32 quest);
	ASCENT_INLINE QuestLogEntry*GetQuestLogInSlot(uint32 slot)  { return m_questlog[slot]; }
    ASCENT_INLINE uint32        GetQuestSharer()                { return m_questSharer; }
    
    ASCENT_INLINE void         SetQuestSharer(uint32 guid)     { m_questSharer = guid; }
    void                SetQuestLogSlot(QuestLogEntry *entry, uint32 slot);
    
    ASCENT_INLINE void   PushToRemovedQuests(uint32 questid) { m_removequests.insert(questid);}
	ASCENT_INLINE uint32 GetFinishedDailiesCount() { return (uint32)m_finishedDailyQuests.size(); }
    void                AddToFinishedQuests(uint32 quest_id);
	void				AddToFinishedDailyQuests(uint32 quest_id);
    void                EventTimedQuestExpire(Quest *qst, QuestLogEntry *qle, uint32 log_slot);
	bool				GetQuestRewardStatus(uint32 quest_id);	
	bool                HasFinishedQuest(uint32 quest_id);
	bool				HasFinishedDailyQuest(uint32 quest_id);
	bool                HasQuestForItem(uint32 itemid);
    bool                CanFinishQuest(Quest* qst);
	bool                HasQuestSpell(uint32 spellid);
	void                RemoveQuestSpell(uint32 spellid);
	bool                HasQuestMob(uint32 entry);
	bool                HasQuest(uint32 entry);
	void                RemoveQuestMob(uint32 entry);
	void                RemoveQuestsFromLine(uint32 skill_line);

    //Quest related variables
	std::set<uint32>    m_finisheddailyQuests;
	uint32 m_questbarrier1[25];
	QuestLogEntry*		m_questlog[25];
	uint32 m_questbarrier2[25];
	std::set<uint32>	m_QuestGOInProgress;
	std::set<uint32>	m_removequests;
	std::set<uint32>	m_finishedQuests;
	std::set<uint32>	m_finishedDailyQuests;
	uint32				m_questSharer;
    uint32              timed_quest_slot;
	std::set<uint32>    quest_spells;
	std::set<uint32>    quest_mobs;
	Mutex				DailyMutex; // Pourquoi faire ?? (Branruz)
    
    void EventPortToGM(Player *p);
	ASCENT_INLINE uint32 GetTeam() { return m_team; }
	ASCENT_INLINE void SetTeam(uint32 t) { m_team = t; m_bgTeam=t; }
	ASCENT_INLINE void ResetTeam() { m_team = myRace->TeamId==0 ? FACTION_ALLY : FACTION_HORDE; m_bgTeam=m_team; }

	ASCENT_INLINE bool IsInFeralForm()
	{
		int s = GetShapeShift();
		if( s <= 0 )
			return false;

		//Fight forms that do not use player's weapon
		return ( s == 1 || s == 5 || s == 8 );
	}
	void CalcDamage();
	uint32 GetMainMeleeDamage(uint32 AP_owerride); //i need this for windfury

    const uint64& GetSelection( ) const { return m_curSelection; }
	const uint64& GetTarget( ) const { return m_curTarget; }
	void SetSelection(const uint64 &guid) { m_curSelection = guid; }
	void SetTarget(const uint64 &guid) { m_curTarget = guid; }
	// Confirm target vs ImplicitTarget ( Spell Item et Go )
	uint8 ConfirmPlayerTarget( SpellCastTargets * targets,Object * _Caster,uint32 _Id, uint32 _EffectImplicitTarget );
	
    /************************************************************************/
    /* Spells                                                               */
    /************************************************************************/
	uint32 GetMaxRankByHash(uint32 namehash);
	bool HasSpell(uint32 spell);
	bool HasTalentWithSpellID( uint32 SpellId );
	bool HasDeletedSpell(uint32 spell);
	void smsg_InitialSpells();
	//void smsg_TalentsInfo(bool update, uint32 newTalentId, uint8 newTalentRank);
	void smsg_TalentsInfo(bool pet);
	void BuildFullTalentsInfo(WorldPacket *data, bool self);
	void BuildPetTalentsInfo(WorldPacket *data);
	void addSpell(uint32 spell_id);
	void removeSpellByHashName(uint32 hash);
	bool removeSpell(uint32 SpellID, bool MoveToDeleted, bool SupercededSpell, uint32 SupercededSpellID);

    // PLEASE DO NOT INLINE!
    void AddOnStrikeSpell(SpellEntry* sp, uint32 delay)
    {
        m_onStrikeSpells.insert( map< SpellEntry*, pair<uint32, uint32> >::value_type( sp, make_pair( delay, 0 ) ) );
    }
    void RemoveOnStrikeSpell(SpellEntry *sp)
    {
        m_onStrikeSpells.erase(sp);
    }
    void AddOnStrikeSpellDamage(uint32 spellid, uint32 mindmg, uint32 maxdmg)
    {
        OnHitSpell sp;
        sp.spellid = spellid;
        sp.mindmg = mindmg;
        sp.maxdmg = maxdmg;
        m_onStrikeSpellDmg[spellid] = sp;
    }
    void RemoveOnStrikeSpellDamage(uint32 spellid)
    {
        m_onStrikeSpellDmg.erase(spellid);
    }

    //Spells variables
    StrikeSpellMap      m_onStrikeSpells;
    StrikeSpellDmgMap   m_onStrikeSpellDmg;
    SpellOverrideMap    mSpellOverrideMap;
    SpellSet            mSpells;
    SpellSet            mDeletedSpells;
	SpellSet			mShapeShiftSpells;
	map_t				mSpellsUniqueTargets;

	void AddShapeShiftSpell(uint32 id);
	void RemoveShapeShiftSpell(uint32 id);

    /************************************************************************/
    /* Actionbar                                                            */
    /************************************************************************/
	void  setAction(uint8 button, uint16 action, uint8 type, uint8 misc);
	void  SendInitialActions();
    bool  m_actionsDirty;
	
    /************************************************************************/
    /* Reputation                                                           */
    /************************************************************************/
	void                ModStanding(uint32 Faction, int32 Value);
	int32               GetStanding(uint32 Faction);
	int32               GetBaseStanding(uint32 Faction);
	void                SetStanding(uint32 Faction, int32 Value);
	void                SetAtWar(uint32 Faction, bool Set);
	bool                IsAtWar(uint32 Faction);
	Standing            GetStandingRank(uint32 Faction);
	bool                IsHostileBasedOnReputation(FactionDBC * dbc);
	void                UpdateInrangeSetsBasedOnReputation();
	void                Reputation_OnKilledUnit(Unit * pUnit, bool InnerLoop);
	void                Reputation_OnTalk(FactionDBC * dbc);
	static Standing     GetReputationRankFromStanding(int32 Standing_);
	
	bool titanGrip;
	void ResetTitansGrip();
	
    /************************************************************************/
    /* Factions                                                             */
    /************************************************************************/
	void smsg_InitialFactions();
	uint32 GetFactionId(void) { return(m_team); }
    // factions variables
    int32 pctReputationMod;

    /************************************************************************/
    /* PVP                                                                  */
    /************************************************************************/
	ASCENT_INLINE uint8 GetPVPRank()
	{
		return (uint8)((GetUInt32Value(PLAYER_BYTES_3) >> 24) & 0xFF);
	}
	ASCENT_INLINE void SetPVPRank(int newrank)
	{
		SetUInt32Value(PLAYER_BYTES_3, ((GetUInt32Value(PLAYER_BYTES_3) & 0x00FFFFFF) | (uint8(newrank) << 24)));
	}
	uint32 GetMaxPersonalRating();
	
	static const uint32 PvPRanks[];
    /************************************************************************/
    /* Groups                                                               */
    /************************************************************************/
	void                SetInviter(uint32 pInviter) { m_GroupInviter = pInviter; }
	ASCENT_INLINE uint32       GetInviter() { return m_GroupInviter; }
	ASCENT_INLINE bool         InGroup() { return (m_playerInfo->m_Group != NULL && !m_GroupInviter); }
	bool                IsGroupLeader()
	{
		if(m_playerInfo->m_Group != NULL)
		{
			if(m_playerInfo->m_Group->GetLeader() == m_playerInfo)
				return true;
		}
		return false;
	}
	bool                	   IsGroupMember(Player *plyr);
	ASCENT_INLINE int          HasBeenInvited() { return m_GroupInviter != 0; }
	ASCENT_INLINE Group*       GetGroup() { return m_playerInfo ? m_playerInfo->m_Group : NULL; }
	ASCENT_INLINE uint32	   GetGroupID() { return m_playerInfo != NULL ? m_playerInfo->m_Group? m_playerInfo->m_Group->GetID(): NULL: NULL; }
	ASCENT_INLINE int8		   GetSubGroup() { return m_playerInfo->subGroup; }

	ASCENT_INLINE bool         IsBanned()
	{
		if(m_banned)
		{
			if(m_banned < 100 || (uint32)UNIXTIME < m_banned)
				return true;
		}
		return false;
	}
	ASCENT_INLINE void		SetBanned() { m_banned = 4;}
	ASCENT_INLINE void		SetBanned(string Reason) { m_banned = 4; m_banreason = Reason;}
	ASCENT_INLINE void		SetBanned(uint32 timestamp, string& Reason) { m_banned = timestamp; m_banreason = Reason; }
	ASCENT_INLINE void		UnSetBanned() { m_banned = 0; }
	ASCENT_INLINE string	GetBanReason() {return m_banreason;}

    /************************************************************************/
    /* Guilds                                                               */
    /************************************************************************/
	ASCENT_INLINE  bool        IsInGuild() {return (m_uint32Values[PLAYER_GUILDID] != 0) ? true : false;}
	ASCENT_INLINE uint32       GetGuildId() { return m_uint32Values[PLAYER_GUILDID]; }
	void                SetGuildId(uint32 guildId);
	ASCENT_INLINE uint32       GetGuildRank() { return m_uint32Values[PLAYER_GUILDRANK]; }
	void                SetGuildRank(uint32 guildRank);
	uint32              GetGuildInvitersGuid() { return m_invitersGuid; }
	void                SetGuildInvitersGuid( uint32 guid ) { m_invitersGuid = guid; }
	void                UnSetGuildInvitersGuid() { m_invitersGuid = 0; }

    /************************************************************************/
    /* Duel                                                                 */
    /************************************************************************/
    void                RequestDuel(Player *pTarget);
	void                DuelBoundaryTest();
	void                EndDuel(uint8 WinCondition);
	void                DuelCountdown();
	void                SetDuelStatus(uint8 status) { m_duelStatus = status; }
	ASCENT_INLINE uint8        GetDuelStatus() { return m_duelStatus; }
	void                SetDuelState(uint8 state) { m_duelState = state; }
	ASCENT_INLINE uint8        GetDuelState() { return m_duelState; }
    // duel variables
    Player*             DuelingWith;

    /************************************************************************/
    /* Trade                                                                */
    /************************************************************************/
	void                SendTradeUpdate(void);
	void         ResetTradeVariables()
	{
		mTradeGold = 0;
		for(uint8 i = 0; i < 7; ++i)
			mTradeItems[i] = NULL;

		mTradeStatus = 0;
		mTradeTarget = 0;
		m_tradeSequence = 2;
	}
	
    /************************************************************************/
    /* Pets                                                                 */
    /************************************************************************/
	uint32						GeneratePetNumber(void);
	void						RemovePlayerPet(uint32 pet_number);
	ASCENT_INLINE void			AddPlayerPet(PlayerPet* pet, uint32 index) { m_Pets[index] = pet; }
	ASCENT_INLINE PlayerPet*	GetPlayerPet(uint32 idx)
	{
		std::map<uint32, PlayerPet*>::iterator itr = m_Pets.find(idx);
		if(itr != m_Pets.end()) return itr->second;
		else
			return NULL;
	}
	void						SpawnPet(uint32 pet_number);
	void						DespawnPet();

	uint32 GetFirstPetNumber(void)
	{
		if(m_Pets.size() == 0) return 0;
		std::map<uint32, PlayerPet*>::iterator itr = m_Pets.begin();
		return itr->first;
	}
	ASCENT_INLINE PlayerPet*	GetFirstPet(void) { return GetPlayerPet(GetFirstPetNumber()); }
	ASCENT_INLINE void			SetStableSlotCount(uint8 count) { m_StableSlotCount = count; }
	ASCENT_INLINE uint8			GetStableSlotCount(void) { return m_StableSlotCount; }

	uint32	GetUnstabledPetNumber(void)
	{
		if(m_Pets.size() == 0) return 0;
		std::map<uint32, PlayerPet*>::iterator itr = m_Pets.begin();
		for(;itr != m_Pets.end();itr++)
			if(itr->second->stablestate == STABLE_STATE_ACTIVE)
				return itr->first;
		return 0;
	}
	void EventSummonPet(Pet *new_pet); //if we charmed or simply summoned a pet, this function should get called
	void EventDismissPet(); //if pet/charm died or whatever happned we should call this function

    /************************************************************************/
    /* Item Interface                                                       */
    /************************************************************************/
	ASCENT_INLINE ItemInterface* GetItemInterface() { return m_ItemInterface; } // Player Inventory Item storage
	ASCENT_INLINE void         ApplyItemMods(Item *item, int8 slot, bool apply,bool justdrokedown=false) {  _ApplyItemMods(item, slot, apply,justdrokedown); }
    // item interface variables
    ItemInterface *     m_ItemInterface;
	void EventCheckCurrencies();

    ASCENT_INLINE AchievementInterface* GetAchievementInterface() { return m_achievementInterface; }
	AchievementInterface * m_achievementInterface;
	
	/************************************************************************/
	/* Loot                                                                 */
	/************************************************************************/
	ASCENT_INLINE const uint64& GetLootGUID() const { return m_lootGuid; }
	ASCENT_INLINE void         SetLootGUID(const uint64 &guid) { m_lootGuid = guid; }
	void                SendLoot(uint64 guid,uint8 loot_type);
    // loot variables
    uint64              m_lootGuid;
    uint64              m_currentLoot;
    bool                bShouldHaveLootableOnCorpse;

    /************************************************************************/
    /* World Session                                                        */
    /************************************************************************/
	ASCENT_INLINE WorldSession* GetSession() const { return m_session; }
	void SetSession(WorldSession *s) { m_session = s; }
	void SetBindPoint(float x, float y, float z, uint32 m, uint32 v) { m_bind_pos_x = x; m_bind_pos_y = y; m_bind_pos_z = z; m_bind_mapid = m; m_bind_zoneid = v;}
	void SendDelayedPacket(WorldPacket *data, bool bDeleteOnSend)
	{
		if(data == NULL) return;
		if(GetSession() != NULL) GetSession()->SendPacket(data);
		if(bDeleteOnSend) delete data;
	}
	float offhand_dmg_mod;
	float GetSpellTimeMod(uint32 id);
	int GetSpellDamageMod(uint32 id);
	int32 GetSpellManaMod(uint32 id);
	
	// Talents
	// These functions build a specific type of A9 packet
	uint32 __fastcall BuildCreateUpdateBlockForPlayer( ByteBuffer *data, Player *target );
	void DestroyForPlayer( Player *target ) const;
	void SetTalentHearthOfWildPCT(int value){hearth_of_wild_pct=value;}
	void EventTalentHearthOfWildChange(bool apply);
	
	std::list<LoginAura> loginauras;

	std::set<uint32> OnMeleeAuras;

	/************************************************************************/
	/* Player loading and savings                                           */
	/* Serialize character to db                                            */
	/************************************************************************/
	void SaveToDB(bool bNewCharacter);
	void SaveAuras(stringstream&);
	bool LoadFromDB(uint32 guid);
	void LoadFromDBProc(QueryResultVector & results);

	void LoadNamesFromDB(uint32 guid);
	bool m_FirstLogin;

    /************************************************************************/
    /* Death system                                                         */
    /************************************************************************/
	void SpawnCorpseBody();
	void SpawnCorpseBones();
	Corpse* CreateCorpse(); //void CreateCorpse();
	void KillPlayer();
	void ResurrectPlayer(Player* pResurrector);

	void BuildPlayerRepop();
	Corpse* RepopRequestedPlayer();   //void RepopRequestedPlayer();
	void EventRepopRequestedPlayer() { RepopRequestedPlayer(); } // Ou veux tu en venir Zed/Andy ?? (Branruz)

	void DeathDurabilityLoss(double percent);
	void RepopAtGraveyard(float ox, float oy, float oz, uint32 mapid);
	
    /************************************************************************/
    /* Movement system                                                      */
    /************************************************************************/
	void SetMovement(uint8 pType, uint32 flag);
	void SetPlayerSpeed(uint8 SpeedType, float value);
	float GetPlayerSpeed(){return m_runSpeed;}
	uint8 m_currentMovement;
	bool m_isMoving;
	uint8 m_isWaterWalking;
	//Invisibility stuff
	bool m_isGmInvisible;
	
    /************************************************************************/
    /* Channel stuff                                                        */
    /************************************************************************/
#ifdef CLUSTERING	
	void JoinedChannel(uint32 channelId);
	void LeftChannel(uint32 channelId);
#else
	void JoinedChannel(Channel *c);
	void LeftChannel(Channel *c);
#endif
	void CleanupChannels();
	//Attack stuff
	void EventAttackStart();
	void EventAttackStop();
	void EventAttackUpdateSpeed() { }
	void EventDeath();
	//Note:ModSkillLine -> value+=amt;ModSkillMax -->value=amt; --wierd
	float GetSkillUpChance(uint32 id);
	//ASCENT_INLINE std::list<struct skilllines>getSkillLines() { return m_skilllines; }
	float SpellCrtiticalStrikeRatingBonus;
	float SpellHasteRatingBonus;
	void UpdateAttackSpeed();
	void UpdateChances();
	void UpdateStats();
	void UpdateHit(int32 hit);

	bool canCast(SpellEntry *m_spellInfo);
	ASCENT_INLINE float GetBlockFromSpell() { return m_blockfromspell; }
	ASCENT_INLINE float GetSpellCritFromSpell() { return m_spellcritfromspell; }
	ASCENT_INLINE float GetHitFromMeleeSpell() { return m_hitfrommeleespell; }
	ASCENT_INLINE float GetHitFromSpell() { return m_hitfromspell; }
	ASCENT_INLINE float GetParryFromSpell() { return m_parryfromspell; }
	ASCENT_INLINE float GetDodgeFromSpell() { return m_dodgefromspell; }
	void SetBlockFromSpell(float value) { m_blockfromspell = value; }
	void SetSpellCritFromSpell(float value) { m_spellcritfromspell = value; }
	void SetParryFromSpell(float value) { m_parryfromspell = value; }
	void SetDodgeFromSpell(float value) { m_dodgefromspell = value; }
	void SetHitFromMeleeSpell(float value) { m_hitfrommeleespell = value; }
	void SetHitFromSpell(float value) { m_hitfromspell = value; }
	ASCENT_INLINE int32 GetHealthFromSpell() { return m_healthfromspell; }
	ASCENT_INLINE uint32 GetManaFromSpell() { return m_manafromspell; }
	void SetHealthFromSpell(int32 value) { m_healthfromspell = value;}
	void SetManaFromSpell(uint32 value) { m_manafromspell = value;}
	uint32 CalcTalentResetCost(uint32 resetnum);
	void SendTalentResetConfirm();
	void SendPetUntrainConfirm();
	void SendDualTalentConfirm();
	uint32 GetTalentResetTimes() { return m_talentresettimes; }
	ASCENT_INLINE void SetTalentResetTimes(uint32 value) { m_talentresettimes = value; }
	void SetPlayerStatus(uint8 pStatus) { m_status = pStatus; }
	ASCENT_INLINE uint8 GetPlayerStatus() { return m_status; }
	const float& GetBindPositionX( ) const { return m_bind_pos_x; }
	const float& GetBindPositionY( ) const { return m_bind_pos_y; }
	const float& GetBindPositionZ( ) const { return m_bind_pos_z; }
	const uint32& GetBindMapId( ) const { return m_bind_mapid; }
	const uint32& GetBindZoneId( ) const { return m_bind_zoneid; }

	void SetShapeShift(uint8 ss);
	ASCENT_INLINE uint8 GetShapeShift()
	{
		return GetByte(UNIT_FIELD_BYTES_2,3);
	}

	
	void delayAttackTimer(int32 delay)
	{
		if(!delay)
			return;

		m_attackTimer += delay;
		m_attackTimer_1 += delay;
	}
	
	uint32 m_furorChance;

    //Showing Units WayPoints
	AIInterface* waypointunit;
	
	uint32 m_nextSave;
	//Tutorials
	uint32 GetTutorialInt(uint32 intId );
	void SetTutorialInt(uint32 intId, uint32 value);
	//Base stats calculations
	//void CalcBaseStats();
	// Rest
	uint32 SubtractRestXP(uint32 amount);
	void AddCalculatedRestXP(uint32 seconds);
	void ApplyPlayerRestState(bool apply);
	void UpdateRestState();

	bool m_noFallDamage;
	float z_axisposition;
	int32 m_safeFall;
	// Gossip
	GossipMenu* CurrentGossipMenu;
	void CleanupGossipMenu();
	void Gossip_Complete();
	int m_lifetapbonus;
	uint32 m_lastShotTime;
	
	bool m_bUnlimitedBreath;
	uint32 m_UnderwaterTime;
	uint32 m_UnderwaterState;
	uint32 m_SwimmingTime;
	uint32 m_BreathDamageTimer;
	// Visible objects
	bool CanSee(Object* obj);
	ASCENT_INLINE bool IsVisible(Object* pObj) { return !(m_visibleObjects.find(pObj) == m_visibleObjects.end()); }
	void AddInRangeObject(Object* pObj);
	void OnRemoveInRangeObject(Object* pObj);
	void ClearInRangeSet();
	ASCENT_INLINE void AddVisibleObject(Object* pObj) { m_visibleObjects.insert(pObj); }
	ASCENT_INLINE void RemoveVisibleObject(Object* pObj) { m_visibleObjects.erase(pObj); }
	ASCENT_INLINE void RemoveVisibleObject(InRangeSet::iterator itr) { m_visibleObjects.erase(itr); }
	ASCENT_INLINE InRangeSet::iterator FindVisible(Object * obj) { return m_visibleObjects.find(obj); }
	ASCENT_INLINE void RemoveIfVisible(Object * obj)
	{
		InRangeSet::iterator itr = m_visibleObjects.find(obj);
		if(itr == m_visibleObjects.end())
			return;

		m_visibleObjects.erase(obj);
		PushOutOfRange(obj->GetNewGUID());
	}

	ASCENT_INLINE bool GetVisibility(Object * obj, InRangeSet::iterator *itr)
	{
		*itr = m_visibleObjects.find(obj);
		return ((*itr) != m_visibleObjects.end());
	}

	ASCENT_INLINE InRangeSet::iterator GetVisibleSetBegin() { return m_visibleObjects.begin(); }
	ASCENT_INLINE InRangeSet::iterator GetVisibleSetEnd() { return m_visibleObjects.end(); }
	
	ASCENT_INLINE void RemovePVPCombat()
	{
		m_pvpcombat = false;

		for (ObjectSet::iterator i=GetInRangeSetBegin(); i!=GetInRangeSetEnd(); ++i)
		if (!sEventMgr.HasEvent(*i, EVENT_INRANGESET_UPDATE))
			sEventMgr.AddEvent(*i, &Object::UpdateOppFactionSet, EVENT_INRANGESET_UPDATE, 1, 1, 0);
	}

	ASCENT_INLINE void SetPVPCombat()
	{
		m_pvpcombat = true;
		sEventMgr.AddEvent(this, &Player::RemovePVPCombat, EVENT_UNK, 8000, 1, EVENT_FLAG_DO_NOT_EXECUTE_IN_WORLD_CONTEXT);

		for (ObjectSet::iterator i=GetInRangeSetBegin(); i!=GetInRangeSetEnd(); ++i)
			if (!sEventMgr.HasEvent(*i, EVENT_INRANGESET_UPDATE))
				sEventMgr.AddEvent(*i, &Object::UpdateOppFactionSet, EVENT_INRANGESET_UPDATE, 1, 1, 0);
	}

	//******    Transporters
	// Gestion de la latence player (Branruz)
	uint32 SyncPlayerLatency;
	uint32 SyncCurrentTickNumber;
	uint32 SyncPlayerTickNumber;
	uint32 SyncServeurTickNumber; // Numero de la Synchro client/serveur
	uint32 SyncServeurTickCount; 
    uint32 SyncPlayerTickCount;   // Synchro client/serveur

	bool m_pvpcombat;
	bool m_lockTransportVariables;
	uint64 m_TransporterGUID;
	float m_TransporterX;
	float m_TransporterY;
	float m_TransporterZ;
	float m_TransporterO;
	float m_TransporterUnk;
	// Position du joueur par Randdrick ( Transports )
	float m_positionX;
	float m_positionY;
	float m_positionZ;
	//**********************
	// Misc
	void EventCannibalize(uint32 amount);
	void EventReduceDrunk(bool full);
	bool m_AllowAreaTriggerPort;
	void EventAllowTiggerPort(bool enable);
	float m_rangedattackspeedmod;
	float m_meleeattackspeedmod;
	uint32 m_modblockabsorbvalue;
	uint32 m_modblockvaluefromspells;
	void SendInitialLogonPackets();
	void Reset_Spells();
	void LearnTalent(uint32 talent_id, uint32 requested_rank);
	void Reset_Talents();
	void Reset_ToLevel1();
	void RetroactiveCompleteQuests();

	// Battlegrounds xD
	CBattleground * m_bg;
	CBattleground * m_pendingBattleground[3];
	uint32 m_bgEntryPointMap;
	float m_bgEntryPointX;	
	float m_bgEntryPointY;
	float m_bgEntryPointZ;
	float m_bgEntryPointO;
	int32 m_bgEntryPointInstance;
	bool m_bgHasFlag;
	bool m_bgIsQueued[3];
	uint32 m_bgQueueType[3];
	uint32 m_bgQueueInstanceId[3];
	uint32 m_bgQueueTime[3];
	uint32 m_bgFlagIneligible;
	uint32 m_bgSlot;
	bool m_bgRatedQueue;


	bool HasBattlegroundQueueSlot();
	uint32 GetBGQueueSlot();
	uint32 HasBGQueueSlotOfType(uint32 type);
	uint32 GetBGQueueSlotByBGType(uint32 type);

	//--------
	void EventRepeatSpell();
	void EventCastRepeatedSpell(uint32 spellid, Unit *target);
	int32 CanShootRangedWeapon(uint32 spellid, Unit *target, bool autoshot);
	uint32 m_AutoShotDuration;
	uint32 m_AutoShotAttackTimer;
	bool m_onAutoShot;
	uint64 m_AutoShotTarget;
	SpellEntry *m_AutoShotSpell;
	void _InitialReputation();
	void EventActivateGameObject(GameObject* obj);
	void EventDeActivateGameObject(GameObject* obj);
	void UpdateNearbyGameObjects();

	void CalcResistance(uint32 type);
	ASCENT_INLINE float res_M_crit_get(){return m_resist_critical[0];}
	ASCENT_INLINE void res_M_crit_set(float newvalue){m_resist_critical[0]=newvalue;}
	ASCENT_INLINE float res_R_crit_get(){return m_resist_critical[1];}
	ASCENT_INLINE void res_R_crit_set(float newvalue){m_resist_critical[1]=newvalue;}

	uint32 FlatStatModNeg[5];
	uint32 StatModPctNeg[5];
	uint32 TotalStatModPctNeg[5];

	uint32 FlatResistanceModifierPos[7];
	uint32 FlatResistanceModifierNeg[7];
	uint32 BaseResistanceModPctPos[7];
	uint32 BaseResistanceModPctNeg[7];
	uint32 ResistanceModPctPos[7];
	uint32 ResistanceModPctNeg[7];
	float m_resist_critical[2];//when we are a victim we can have talents to decrease chance for critical hit. This is a negative value and it's added to critchances
	float m_resist_hit[3]; // 0 = melee; 1= ranged; 2=spells
	/*float SpellDmgDoneByAttribute[5][7];
	float SpellHealDoneByAttribute[5][7];*/
	uint32 m_modphyscritdmgPCT;
	uint32 m_RootedCritChanceBonus; // Class Script Override: Shatter

	/*uint32 m_ModInterrMRegenPCT;
	int32 m_ModInterrMRegen;*/
	float m_RegenManaOnSpellResist;
	uint32 m_casted_amount[7]; //Last casted spells amounts. Need for some spells. Like Ignite etc. DOesn't count HoTs and DoTs. Only directs
	
	int32 IncreaseDamageByType[12]; //mod dmg by creature type
	float IncreaseDamageByTypePCT[12];
	float IncreaseCricticalByTypePCT[12];
	int32 DetectedRange;
	float PctIgnoreRegenModifier;
	uint32 m_retainedrage;
/*	
	union {
		float mRatingToPct[37];
		uint32 mRatingToPoint[37]; //block, skill.. cant be decimal values
	};
*/
	ASCENT_INLINE uint32* GetPlayedtime() { return m_playedtime; };
	void CalcStat(uint32 t);
	ASCENT_INLINE float CalcRating(uint32 index) { return CalcPercentForRating(index, m_uint32Values[index]); };
	float CalcPercentForRating(uint32 index, uint32 rating);
	//float CalcRating(uint32 t);
	void RecalcAllRatings();
	void RegenerateMana(bool is_interrupted);
	void RegenerateHealth(bool inCombat);
	void RegenerateEnergy();
	void LooseRage(int32 value);
	void LooseRunic(int32 value);
	void SetRage(int32 value);
	
    uint32 SoulStone;
	uint32 SoulStoneReceiver;
	void removeSoulStone();

    ASCENT_INLINE uint32 GetSoulStoneReceiver(){return SoulStoneReceiver;}
    ASCENT_INLINE void SetSoulStoneReceiver(uint32 StoneGUID){SoulStoneReceiver = StoneGUID;}
    ASCENT_INLINE uint32 GetSoulStone(){return SoulStone;}
    ASCENT_INLINE void SetSoulStone(uint32 StoneID){SoulStone = StoneID;}

	bool bReincarnation;

	map<uint32, WeaponModifier> damagedone;
	map<uint32, WeaponModifier> tocritchance;
	uint32 Seal;
	uint32 judgespell;
	bool cannibalize;
	uint8 cannibalizeCount;
	int32 rageFromDamageDealt;
	// GameObject commands
	GameObject *m_GM_SelectedGO;
	
#ifndef CLUSTERING
	void _Relocate(uint32 mapid,const LocationVector & v, bool sendpending, bool force_new_world, uint32 instance_id);
#endif
	void AddItemsToWorld();
	void RemoveItemsFromWorld();
	void UpdateKnownCurrencies(uint32 ItemId, bool apply);
	
	uint32 m_ShapeShifted;
	uint32 m_MountSpellId;

	bool m_AreaGoTriggered; // Lock pour OnActivateGoArea()
    
	ASCENT_INLINE bool IsMounted() {return (m_MountSpellId!=0 ? true : false); }
	ASCENT_INLINE uint32 GetMountSpellId() {return (m_MountSpellId); }
	ASCENT_INLINE void ResetMountSpellId() { m_MountSpellId = 0; }
	
    bool bHasBindDialogOpen;
	bool bGMTagOn;
	uint32 TrackingSpell;
	void _EventCharmAttack();
	void _Warn(const char *message);
	void _Kick();
	void _Disconnect();
	void Kick(uint32 delay = 0);
	void SoftDisconnect();
	uint32 m_KickDelay;
	Unit * m_CurrentCharm;
	Transporter * m_CurrentTransporter;
	
	Object * GetSummonedObject () {return m_SummonedObject;};
	void SetSummonedObject (Object * t_SummonedObject) {m_SummonedObject = t_SummonedObject;};
	uint32 roll;

	void ClearCooldownsOnLine(uint32 skill_line, uint32 called_from);
	void ResetAllCooldowns();
	void ClearCooldownForSpell(uint32 spell_id);

	bool bProcessPending;
	Mutex _bufferS;
	void PushUpdateData(ByteBuffer *data, uint32 updatecount);
	void PushUpdateData(StackBuffer *data, uint32 updatecount);
    void PushCreationData(ByteBuffer *data, uint32 updatecount);
	void PushOutOfRange(const WoWGuid & guid);
	void ProcessPendingUpdates(ByteBuffer *pBuildBuffer, ByteBuffer *pCompressionBuffer);
	bool __fastcall CompressAndSendUpdateBuffer(uint32 size, const uint8* update_buffer, ByteBuffer *pCompressionBuffer);
	void ClearAllPendingUpdates();
	
	uint32 GetArmorProficiency() { return armor_proficiency; }
	uint32 GetWeaponProficiency() { return weapon_proficiency; }

	void ResetHeartbeatCoords();

	// speedhack buster!
	LocationVector _lastHeartbeatPosition;
	float _lastHeartbeatV; // velocity
	uint32 _startMoveTime;	// time
	uint32 m_lastMovementPacketTimestamp;
	uint32 _lastMoveTime;
	int32 _heartbeatDisable;
	uint32 m_lastMoveTime;
	bool _speedChangeInProgress;
	uint32 m_flyHackChances;

	void AddSplinePacket(uint64 guid, ByteBuffer* packet);
	ByteBuffer* GetAndRemoveSplinePacket(uint64 guid);
	void ClearSplinePackets();
	bool ExitInstance();
	void SaveEntryPoint(uint32 mapId);
	bool CooldownCheat;
	bool CastTimeCheat;
	bool GodModeCheat;
	bool PowerCheat;
	bool FlyCheat;
	void ZoneUpdate(uint32 ZoneId);
	ASCENT_INLINE uint32 GetAreaID() { return m_AreaID; }
	void SetAreaID(uint32 area) { m_AreaID = area; m_areaDBC = dbcArea.LookupEntryForced(m_AreaID); }
	ASCENT_INLINE AreaTable *GetAreaDBC() { return m_areaDBC; }
	
	
	std::string Lfgcomment;
	uint16 LfgDungeonId[3];
	uint8 LfgType[3];
	uint16 LfmDungeonId;
	uint8 LfmType;
	bool m_Autojoin;
	bool m_AutoAddMem;
	void StopMirrorTimer(uint32 Type);
	BGScore m_bgScore;
	uint32 m_bgTeam;
	void UpdateChanceFields();
	//Honor Variables
	time_t m_fallDisabledUntil;
	uint32 m_honorToday;
	uint32 m_honorYesterday;
	
	void RolloverHonor();
	uint32 m_honorPoints;
	uint32 m_honorRolloverTime;
	uint32 m_killsToday;
	uint32 m_killsYesterday;
	uint32 m_killsLifetime;
	uint32 m_arenaPoints;
	bool m_honorless;
	uint32 m_lastSeenWeather;
	set<Object*> m_visibleFarsightObjects;
	void EventTeleport(uint32 mapid, float x, float y, float z);
	void ApplyLevelInfo(LevelInfo* Info, uint32 Level);
	void BroadcastMessage(const char* Format, ...);
	map<uint32, set<uint32> > SummonSpells;
	map<uint32, PetSpellMap*> PetSpells;
	void AddSummonSpell(uint32 Entry, uint32 SpellID);
	void RemoveSummonSpell(uint32 Entry, uint32 SpellID);
	set<uint32>* GetSummonSpells(uint32 Entry);
	LockedQueue<WorldPacket*> delayedPackets;
	set<Player *> gmTargets;
	uint32 m_UnderwaterMaxTime;
	uint32 m_UnderwaterLastDmg;
	ASCENT_INLINE void setMyCorpse(Corpse * corpse) { myCorpse = corpse; }
	ASCENT_INLINE Corpse * getMyCorpse() { return myCorpse; }
	bool bCorpseCreateable;
	uint32 m_resurrectHealth, m_resurrectMana;
	uint32 resurrector;
	LocationVector m_resurrectLocation;
	bool blinked;
	uint16 m_speedhackChances;
	uint16 m_cheatEngineChances;
	uint32 m_explorationTimer;
	// DBC stuff
	CharRaceEntry * myRace;
	CharClassEntry * myClass;
	Unit * linkTarget;
	bool stack_cheat;
	bool triggerpass_cheat;
	bool SafeTeleport(uint32 MapID, uint32 InstanceID, float X, float Y, float Z, float O);
	bool SafeTeleport(uint32 MapID, uint32 InstanceID, const LocationVector & vec);
	void SafeTeleport(MapMgr * mgr, const LocationVector & vec);
	void EjectFromInstance();
	bool raidgrouponlysent;

#ifdef CLUSTERING
	RPlayerInfo * UpdateRPlayerInfo(RPlayerInfo * pRPlayer, bool newRplr = false)
	{
		pRPlayer->Guid = GetLowGUID();
		pRPlayer->AccountId = GetSession()->GetAccountId();
		pRPlayer->Name = GetName();
		pRPlayer->Level= getLevel() ;
		pRPlayer->GuildId = GetGuildId();
		pRPlayer->PositionX = GetPositionX();
		pRPlayer->PositionY = GetPositionY();
		pRPlayer->PositionY = GetPositionZ();
		pRPlayer->ZoneId = m_zoneId;
		pRPlayer->Race = getRace();
		pRPlayer->Class = getClass();
		pRPlayer->Gender = getGender();
		pRPlayer->Latency = GetSession()->GetLatency();
		pRPlayer->GMPermissions = GetSession()->HasPermissions();
		pRPlayer->Account_Flags = GetSession()->GetAccountFlags();
		pRPlayer->InstanceId = GetInstanceID();
		pRPlayer->MapId = GetMapId();
		pRPlayer->iInstanceType = iInstanceType;
		pRPlayer->ClientBuild = GetSession()->GetClientBuild();
		pRPlayer->Team = m_team;
		if(newRplr)
			pRPlayer->references = 1;
		return pRPlayer;
	}
#endif

	void EventSafeTeleport(uint32 MapID, uint32 InstanceID, LocationVector vec)
	{
		SafeTeleport(MapID, InstanceID, vec);
	}

	/*****************
	  PVP Stuff
	******************/
	uint32 m_pvpTimer;
	
	//! Is PVP flagged?
	//ASCENT_INLINE bool IsPvPFlagged() { return HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP); }
	ASCENT_INLINE bool IsPvPFlagged() { return HasByteFlag(UNIT_FIELD_BYTES_2, 1, U_FIELD_BYTES_FLAG_PVP); }
	ASCENT_INLINE bool IsPvPFlaggedFFA() { return HasByteFlag(UNIT_FIELD_BYTES_2, 1, U_FIELD_BYTES_FLAG_FFA_PVP); }
	ASCENT_INLINE void SetPvPFlag()
	{
		// reset the timer as well..
		StopPvPTimer();
		//SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP);
		SetByteFlag(UNIT_FIELD_BYTES_2, 1, U_FIELD_BYTES_FLAG_PVP);
	}
	//! Removal
	ASCENT_INLINE void RemovePvPFlag()
	{
		StopPvPTimer();
		//RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP);
		RemoveByteFlag(UNIT_FIELD_BYTES_2, 1, U_FIELD_BYTES_FLAG_PVP);
	}
	// FFA Flag (Branruz)
	ASCENT_INLINE void SetPvPFlagFFA()
	{
		SetByteFlag(UNIT_FIELD_BYTES_2, 1, U_FIELD_BYTES_FLAG_FFA_PVP);
	}
	ASCENT_INLINE void RemovePvPFlagFFA()
	{
		RemoveByteFlag(UNIT_FIELD_BYTES_2, 1,U_FIELD_BYTES_FLAG_FFA_PVP);
		// Deselection sur un combat:
		// Probleme: Le passage du mode FFA au mode JcJ 'normal' permet toujours
		//           a un joueur de taper sur un autre de la meme faction, 
		//           La deselection du joueur stop le probleme

		// Deselection du player de la meme Faction
		/* Marche pas, A FINIR (Branruz)
		uint64 GuidSelected = this->GetSelection();
		if(GuidSelected != NULL)
		{
		  Player *chr = m_session->GetPlayer()->GetMapMgr()->GetPlayer((uint32)GuidSelected);
		  if(chr != NULL ) // Normalement ne devrait pas arriver
		  {
		   if(chr->GetTeam() == this->GetTeam()) 
			  this->CombatStatusHandler_ResetPvPTimeout();
		  }
		}
		*/
	}
	//-----------
	//! Do this on /pvp off
	ASCENT_INLINE void ResetPvPTimer();
	//! Stop the timer for pvp off
	ASCENT_INLINE void StopPvPTimer() { RemoveFlag(PLAYER_FLAGS, PLAYER_FLAG_PVP_TIMER); m_pvpTimer = 0; }
	
	//! Called at login to add the honorless buff, etc.
	void LoginPvPSetup();
	//! Update our pvp area (called when zone changes)
	void UpdatePvPArea();
	//! PvP Toggle (called on /pvp)
	void PvPToggle();

	// Test, Les SpellEffects 
	void UpdateSpellEffectArea(); // Waad
	void OnActivateGoArea(uint32 zone_id);       // Waad

	ASCENT_INLINE uint32 LastHonorResetTime() const { return m_lastHonorResetTime; }
	ASCENT_INLINE void LastHonorResetTime(uint32 val) { m_lastHonorResetTime = val; }
	uint32 OnlineTime;
	bool tutorialsDirty;
	LevelInfo * lvlinfo;
	void CalculateBaseStats();
	uint32 load_health;
	uint32 load_mana;
	void CompleteLoading();
	set<SpellEntry *> castSpellAtLogin;
	void OnPushToWorld();
	void OnPrePushToWorld();
	void OnWorldPortAck();
	void OnTimeSyncRequest(); // (Branruz)
	uint32 m_TeleportState;
	bool m_beingPushed;
	bool CanSignCharter(Charter * charter, Player * requester);
	Charter * m_charters[NUM_CHARTER_TYPES];
	uint32 flying_aura;
	stringstream LoadAuras;
	bool resend_speed;
	bool rename_pending;
	uint32 iInstanceType;
	float  Taille;
	ASCENT_INLINE void SetName(string& name) { m_name = name; }
	// spell to (delay, last time)
	
	FactionReputation * reputationByListId[128];
	
	uint64 m_comboTarget;
	int8 m_comboPoints;
	bool m_retainComboPoints;
	int8 m_spellcomboPoints; // rogue talent Ruthlessness will change combopoints while consuming them. solutions 1) add post cast prochandling, 2) delay adding the CP
	void UpdateComboPoints();

	ASCENT_INLINE void AddComboPoints(uint64 target, uint8 count)
	{
        if(m_comboTarget == target)
			m_comboPoints += count;
		else
		{
			m_comboTarget = target;
			m_comboPoints = count;
		}
		UpdateComboPoints();
	}

	ASCENT_INLINE void NullComboPoints() { if(!m_retainComboPoints) { m_comboTarget = 0; m_comboPoints = 0; m_spellcomboPoints=0; } UpdateComboPoints(); }
	uint32 m_speedChangeCounter;

	// HACKKKKK
	uint32 m_cheatDeathRank;
	
	void SendAreaTriggerMessage(const char * message, ...);
        
	// Trade Target
	//Player *getTradeTarget() {return mTradeTarget;};

	ASCENT_INLINE Player * GetTradeTarget()
	{
		if(!IsInWorld()) return 0;
		return m_mapMgr->GetPlayer((uint32)mTradeTarget);
	}

	Item *getTradeItem(uint32 slot) {return mTradeItems[slot];};
        
	// Water level related stuff (they are public because they need to be accessed fast)
	// Nose level of the character (needed for proper breathing)
	float m_noseLevel;

	/* Mind Control */
	void Possess(Unit * pTarget);
	void UnPossess();

	/* Last Speeds */
	ASCENT_INLINE void UpdateLastSpeeds()
	{
		m_lastRunSpeed = m_runSpeed;
		m_lastRunBackSpeed = m_backWalkSpeed;
		m_lastSwimSpeed = m_swimSpeed;
		m_lastRunBackSpeed = m_backSwimSpeed;
		m_lastFlySpeed = m_flySpeed;
	}

	void RemoteRevive()
	{
		ResurrectPlayer(NULL);
		SetMovement(MOVE_UNROOT, 5);
		SetPlayerSpeed(RUN, (float)7);
		SetPlayerSpeed(SWIM, (float)4.9);
		SetMovement(MOVE_LAND_WALK, 8);
		SetUInt32Value(UNIT_FIELD_HEALTH, GetUInt32Value(UNIT_FIELD_MAXHEALTH) );
	}

	void ResetSpeedHack();
	void DelaySpeedHack(uint32 ms);

	LocationVector m_last_group_position;
	int32 m_rap_mod_pct;
	void SummonRequest(uint32 Requestor, uint32 ZoneID, uint32 MapID, uint32 InstanceID, const LocationVector & Position);
	uint8 m_lastMoveType;
#ifdef OPTIMIZED_PLAYER_SAVING
	void save_LevelXP();
	void save_Skills();
	void save_ExploreData();
	void save_Gold();
	void save_Misc();
	void save_PositionHP();
	void save_BindPosition();
	void save_Honor();
	void save_EntryPoint();
	void save_Taxi();
	void save_Transporter();
	void save_Spells();
	void save_Actions();
	void save_Reputation();
	void save_Auras();
	void save_InstanceType();
	void save_Zone();
	void save_PVP();
#endif

#ifdef CLUSTERING
	void EventRemoveAndDelete();
	void PackPlayerData(ByteBuffer & data);
	bool UnpackPlayerData(ByteBuffer & data);
#endif

	//Creature * m_tempSummon; // A quoi sert ce truc, viré temporairement (Branruz)
	bool m_deathVision;
	SpellEntry * last_heal_spell;
	LocationVector m_sentTeleportPosition;

	void RemoveFromBattlegroundQueue(uint32 queueSlot, bool forced = false);
	void FullHPMP();
	uint32 m_arenateaminviteguid;

    /************************************************************************/
    /* Spell Packet wrapper Please keep this separated                      */
    /************************************************************************/
    void SendLevelupInfo(uint32 level, uint32 Hp, uint32 Mana, uint32 Stat0, uint32 Stat1, uint32 Stat2, uint32 Stat3, uint32 Stat4);
    void SendLogXPGain(uint64 guid, uint32 NormalXP, uint32 RestedXP, bool type);
    void SendEnvironmentalDamageLog(const uint64 & guid, uint8 type, uint32 damage);
	void SendWorldStateUpdate(uint32 WorldState, uint32 Value); // Seulement pour les ZonesPvP (Branruz)
	void SendCastResult(uint32 SpellId, uint8 ErrorMessage, uint8 MultiCast, uint32 Extra);
	void Gossip_SendPOI(float X, float Y, uint32 Icon, uint32 Flags, uint32 Data, const char* Name);
    /************************************************************************/
    /* End of SpellPacket wrapper                                           */
    /************************************************************************/

	Mailbox m_mailBox;
	bool m_waterwalk;
	bool m_setwaterwalk;
	bool m_setflycheat;
	uint64 m_areaSpiritHealer_guid;
	bool m_finishingmovesdodge;
	bool m_canfly;	

	ASCENT_INLINE bool CanFly() { return m_canfly; }
	ASCENT_INLINE bool IsAttacking() {return m_attacking; }

	static void InitVisibleUpdateBits();
	static UpdateMask m_visibleUpdateMask;

	void CopyAndSendDelayedPacket(WorldPacket * data);
	void PartLFGChannel();
	ASCENT_INLINE void RemovePlayerFromWorld() { delete this; }

	bool HasKnownTitle(uint32 TitleNumber);
	void AddKnownTitle(uint32 TitleNumber);
	void RemoveKnownTitle(uint32 TitleNumber);
	bool PlayerPetHasQueued;

protected:
	LocationVector m_summonPos;
	uint32 m_summonInstanceId;
	uint32 m_summonMapId;
	uint32 m_summoner;

	uint32 iActivePet;
	void _SetCreateBits(UpdateMask *updateMask, Player *target) const;
	void _SetUpdateBits(UpdateMask *updateMask, Player *target) const;

	/* Update system components */
	ByteBuffer bUpdateBuffer;
    ByteBuffer bCreationBuffer;
	uint32 mUpdateCount;
    uint32 mCreationCount;
	uint32 mOutOfRangeIdCount;
	ByteBuffer mOutOfRangeIds;
	SplineMap _splineMap;
	/* End update system */

	void _LoadTutorials(QueryResult * result);
	void _SaveTutorials(QueryBuffer * buf);
	void _SaveInventory(bool firstsave);
	void _SaveQuestLogEntry(QueryBuffer * buf);
	void _LoadQuestLogEntry(QueryResult * result);

	void _LoadSkills(QueryResult * result);
	void _SaveSkillsToDB(QueryBuffer * buf);
	
	void _LoadSpells(QueryResult * result);
	void _SaveSpellsToDB(QueryBuffer * buf);
	
	void _LoadTalents(QueryResult * result);
	void _SaveTalentsToDB(QueryBuffer * buf);
	
	void _LoadGlyphs(QueryResult * result);
	void _SaveGlyphsToDB(QueryBuffer * buf);

	void _LoadPet(QueryResult * result);
	void _LoadPetActionBar(QueryResult * result);
	void _LoadPetNo();
	void _LoadPetSpells(QueryResult * result);
	void _SavePet(QueryBuffer * buf);
	void _SavePetSpells(QueryBuffer * buf);
	void _ApplyItemMods( Item* item, int8 slot, bool apply, bool justdrokedown = false, bool skip_stat_apply = false );
	void _EventAttack( bool offhand );
	void _EventExploration();

	// Water level related stuff
	void SetNoseLevel();

	/************************************************************************/
	/* Trade																*/
	/************************************************************************/
    #define MAX_TRADE_ITEM	7
	Item* mTradeItems[MAX_TRADE_ITEM];
	uint32 mTradeGold;
	uint32 mTradeTarget;
	uint32 mTradeStatus;
	uint32 m_tradeSequence;

    /************************************************************************/
    /* Player Class systems, info and misc things                           */
    /************************************************************************/
    PlayerCreateInfo *info;
	uint32      m_AttackMsgTimer;	// "too far away" and "wrong facing" timer
	bool        m_attacking;
	std::string m_name;	// max 21 character name
	std::string m_ClassName; // Classe Player
	uint32      m_Tutorials[8];

    // Character Ban
	uint32      m_banned;
	string      m_banreason;
	uint32      m_AreaID;
	AreaTable  *m_areaDBC;
	uint32      m_PetNumberMax;
	std::map<uint32, PlayerPet*> m_Pets;
	
    uint32      m_invitersGuid; // It is guild inviters guid ,0 when its not used
    

    // bind
	float m_bind_pos_x;
	float m_bind_pos_y;
	float m_bind_pos_z;
	uint32 m_bind_mapid;
	uint32 m_bind_zoneid;
	std::list<ItemSet> m_itemsets;
	//Duel
	uint32 m_duelCountdownTimer;
	uint8 m_duelStatus;
	uint8 m_duelState;
	// Rested State Stuff
	uint32 m_timeLogoff;
	// Played time
	uint32 m_playedtime[3];
	uint8 m_isResting;
	uint8 m_restState;
	uint32 m_restAmount;
	//combat mods
	float m_blockfromspell;
	float m_blockfromspellPCT;
	float m_critfromspell;
	float m_spellcritfromspell;
	float m_dodgefromspell;
	float m_parryfromspell;
	float m_hitfromspell;
	float m_hitfrommeleespell;
public:
	//stats mods
	/*uint32 m_healthfromspell;
	uint32 m_manafromspell;*/
	uint32 m_healthfromitems;
	uint32 m_manafromitems;

protected:
	
    uint32 armor_proficiency;
	uint32 weapon_proficiency;
	// Talents
	uint32 m_talentresettimes;
	// STATUS
	uint8 m_status;
	// guid of current target
	uint64 m_curTarget;
	// guid of current selection
	uint64 m_curSelection;
	// Raid
	uint8 m_targetIcon;
	//Player Action Bar
	ActionButton mActions[PLAYER_ACTION_BUTTON_SIZE];
	// Player Reputation
	ReputationMap m_reputation;
	// Pointer to this char's game client
	WorldSession *m_session;
	// Channels	
#ifdef CLUSTERING
	std::set<uint32> m_channels;
#else
	std::set<Channel*> m_channels;
#endif	
	// Visible objects
	std::set<Object*> m_visibleObjects;
	// Groups/Raids
	uint32 m_GroupInviter;
	uint8 m_StableSlotCount;

    // Fishing related
	Object *m_SummonedObject;

    // other system
	Corpse *    myCorpse;

	uint32      m_lastHonorResetTime;
	uint32      _fields[PLAYER_END];
	uint32	    trigger_on_stun;        //bah, warrior talent but this will not get triggered on triggered spells if used on proc so i'm forced to used a special variable
	uint32	    trigger_on_stun_chance; //also using this for mage "Frostbite" talent
	int			hearth_of_wild_pct;		//druid hearth of wild talent used on shapeshifting. We eighter know what is last talent level or memo on learn

	uint32 m_team;
	float       m_lastRunSpeed;
	float       m_lastRunBackSpeed;
	float       m_lastSwimSpeed;
	float       m_lastBackSwimSpeed;
	float       m_lastFlySpeed;

	uint32 m_mountCheckTimer;
	void RemovePendingPlayer();
public:
#ifdef ENABLE_COMPRESSED_MOVEMENT
	void EventDumpCompressedMovement();
	void AppendMovementData(uint32 op, uint32 sz, const uint8* data);
	Mutex m_movementBufferLock;
	ByteBuffer m_movementBuffer;
#endif

	void addDeletedSpell(uint32 id) { mDeletedSpells.insert( id ); }

	map<uint32, uint32> m_forcedReactions;

	uint32 m_speedhackCheckTimer;
#ifdef COLLISION
	uint32 m_flyhackCheckTimer;
	void _FlyhackCheck();
#endif
	void _SpeedhackCheck(uint32 mstime);		// save a call to getMSTime() yes i am a stingy bastard

	bool m_passOnLoot;
	bool m_changingMaps;

	/************************************************************************/
	/* SOCIAL                                                               */
	/************************************************************************/
private:
	/* we may have multiple threads on this(chat) - burlex */
	Mutex m_socialLock;
	map<uint32, char*> m_friends;
	set<uint32> m_ignores;
	set<uint32> m_hasFriendList;

	void Social_SendFriendList(uint32 flag);

	void Social_SetNote(uint32 guid, const char * note);

public:
	void Social_AddFriend(const char * name, const char * note);
	void Social_RemoveFriend(uint32 guid);
	
	void Social_AddIgnore(const char * name);
	void Social_RemoveIgnore(uint32 guid);
	bool Social_IsIgnoring(PlayerInfo * m_info);
	bool Social_IsIgnoring(uint32 guid);

	void Social_TellFriendsOnline();
	void Social_TellFriendsOffline();

	/************************************************************************/
	/* end social                                                           */
	/************************************************************************/

	PlayerInfo * m_playerInfo;
	uint32 m_skipCastCheck[3];  // spell group relation of spell types that should ignore some cancast checks
	bool m_castFilterEnabled;
	uint32 m_castFilter[3];	// spell group relation of only spells that player can currently cast 
	uint32 m_outStealthDamageBonusPct;
	uint32 m_outStealthDamageBonusPeriod;
	uint32 m_outStealthDamageBonusTimer;

	int16 m_vampiricEmbrace;
	int16 m_vampiricTouch;
	void VampiricSpell(uint32 dmg, Unit* pTarget);

	// spirit of redemption
	bool m_canCastSpellsWhileDead;
	
	// area update for worldstates, etc.
	void ForceAreaUpdate();
	
	// debuffs
	bool mWeakenedSoul;
	bool mForbearance;
	bool mHypothermia;
	bool mExhaustion;
	bool mSated;

	// Avenging Wrath...
	bool mAvengingWrath;
	void AvengingWrath() { mAvengingWrath = true; }
	// Talent Specs
	uint16 m_maxTalentPoints;
	uint16 GetMaxTalentPoints();
	void ApplySpec(uint8 spec, bool init);
	void ApplyTalent(uint32 spellId);
	void RemoveTalent(uint32 spellid);
	uint8 m_talentSpecsCount;
	uint8 m_talentActiveSpec;
	struct PlayerSpec
	{
		std::map<uint32, uint8> talents;	// map of <talentId, talentRank>
		uint16  glyphs[GLYPHS_COUNT];
	};
	PlayerSpec m_specs[MAX_SPEC_COUNT];

	// Glyphs
	void UnapplyGlyph(uint32 slot);
	uint8 SetGlyph(uint32 slot, uint32 glyphId);
	void InitGlyphSlots();
	void InitGlyphsForLevel();

	// OpenAscent
private:
	// Stuff for "Talent Inspect"
	#define TALENT_INSPECT_BYTES 71
	uint8 m_talentInspectBuffer[TALENT_INSPECT_BYTES];
	bool SetTaximaskNode(uint32 nodeidx);
public:
	ASCENT_INLINE const uint8 *GetTalentInspectBuffer() { return m_talentInspectBuffer; }
	void UpdateTalentInspectBuffer();
	static void InitializeTalentInspectSupport();
	
	//Clustering
	void EventClusterMapChange(uint32 mapid, uint32 instanceid, LocationVector location);
	void HandleClusterRemove();
	void HandlePlayerTeleportServers();
};
	
class SkillIterator
{
	SkillMap::iterator m_itr;
	SkillMap::iterator m_endItr;
	bool m_searchInProgress;
	Player * m_target;
public:
	SkillIterator(Player* target) : m_searchInProgress(false),m_target(target) {}
	~SkillIterator() { if(m_searchInProgress) { EndSearch(); } }

	void BeginSearch()
	{
		// iteminterface doesn't use mutexes, maybe it should :P
		ASSERT(!m_searchInProgress);
		m_itr = m_target->m_skills.begin();
		m_endItr = m_target->m_skills.end();
		m_searchInProgress=true;
	}

	void EndSearch()
	{
		// nothing here either
		ASSERT(m_searchInProgress);
		m_searchInProgress=false;
	}

	PlayerSkill* operator*() const
	{
		return &m_itr->second;
	}

	PlayerSkill* operator->() const
	{
		return &m_itr->second;
	}

	void Increment()
	{
		if(!m_searchInProgress)
			BeginSearch();

		if(m_itr==m_endItr)
			return;

		++m_itr;
	}

	ASCENT_INLINE PlayerSkill* Grab() { return &m_itr->second; }
	ASCENT_INLINE bool End() { return (m_itr==m_endItr)?true:false; }
};

#ifdef ENABLE_COMPRESSED_MOVEMENT

class CMovementCompressorThread : public ThreadBase
{
	bool running;
	Mutex m_listLock;
	set<Player*> m_players;
public:
	CMovementCompressorThread() { running = true; }

	void AddPlayer(Player * pPlayer);
	void RemovePlayer(Player * pPlayer);

	void OnShutdown() { running = false; }
	bool run();
};

extern CMovementCompressorThread * MovementCompressor;

#endif

#endif
